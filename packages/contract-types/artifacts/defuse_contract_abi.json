{
  "schema_version": "0.4.0",
  "metadata": {
    "name": "defuse",
    "version": "0.4.1",
    "build": {
      "compiler": "rustc 1.86.0",
      "builder": "cargo-near cargo-near-build 0.10.0"
    },
    "wasm_hash": "AUxxj33BzcwybeVZV9T6DhC7aAD338FdY3DFmu5A5SrE"
  },
  "body": {
    "functions": [
      {
        "name": "__abi_helper",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "_types",
              "type_schema": {
                "$ref": "#/definitions/AbiHelper"
              }
            }
          ]
        }
      },
      {
        "name": "acl_add_admin",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "role",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": [
              "boolean",
              "null"
            ]
          }
        }
      },
      {
        "name": "acl_add_super_admin",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": [
              "boolean",
              "null"
            ]
          }
        }
      },
      {
        "name": "acl_get_admins",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "role",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "skip",
              "type_schema": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            {
              "name": "limit",
              "type_schema": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "array",
            "items": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            }
          }
        }
      },
      {
        "name": "acl_get_grantees",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "role",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "skip",
              "type_schema": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            {
              "name": "limit",
              "type_schema": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "array",
            "items": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            }
          }
        }
      },
      {
        "name": "acl_get_permissioned_accounts",
        "kind": "view",
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PermissionedAccounts"
          }
        }
      },
      {
        "name": "acl_get_super_admins",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "skip",
              "type_schema": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            },
            {
              "name": "limit",
              "type_schema": {
                "type": "integer",
                "format": "uint64",
                "minimum": 0.0
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "array",
            "items": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            }
          }
        }
      },
      {
        "name": "acl_grant_role",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "role",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": [
              "boolean",
              "null"
            ]
          }
        }
      },
      {
        "name": "acl_has_any_role",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "roles",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "acl_has_role",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "role",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "acl_init_super_admin",
        "kind": "call",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "acl_is_admin",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "role",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "acl_is_super_admin",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "acl_renounce_admin",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "role",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "acl_renounce_role",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "role",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "acl_revoke_admin",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "role",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": [
              "boolean",
              "null"
            ]
          }
        }
      },
      {
        "name": "acl_revoke_role",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "role",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": [
              "boolean",
              "null"
            ]
          }
        }
      },
      {
        "name": "acl_revoke_super_admin",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": [
              "boolean",
              "null"
            ]
          }
        }
      },
      {
        "name": "acl_role_variants",
        "kind": "view",
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "acl_storage_prefix",
        "kind": "view",
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint8",
              "minimum": 0.0
            }
          }
        }
      },
      {
        "name": "acl_transfer_super_admin",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": [
              "boolean",
              "null"
            ]
          }
        }
      },
      {
        "name": "add_full_access_key",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "public_key",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Promise"
          }
        }
      },
      {
        "name": "add_public_key",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "public_key",
              "type_schema": {
                "examples": [
                  "ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
                  "secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"
                ],
                "type": "string",
                "contentEncoding": "base58"
              }
            }
          ]
        }
      },
      {
        "name": "add_relayer_key",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "public_key",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Promise"
          }
        }
      },
      {
        "name": "cleanup_nonces",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "nonces",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "array",
                  "items": [
                    {
                      "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                      "type": "string"
                    },
                    {
                      "type": "array",
                      "items": {
                        "type": "string",
                        "contentEncoding": "base64"
                      }
                    }
                  ],
                  "maxItems": 2,
                  "minItems": 2
                }
              }
            }
          ]
        }
      },
      {
        "name": "contract_source_metadata",
        "kind": "view"
      },
      {
        "name": "current_salt",
        "kind": "view",
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "string",
            "contentEncoding": "hex"
          }
        }
      },
      {
        "name": "delete_key",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "public_key",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Promise"
          }
        }
      },
      {
        "name": "delete_relayer_key",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "public_key",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Promise"
          }
        }
      },
      {
        "name": "disable_auth_by_predecessor_id",
        "kind": "call",
        "modifiers": [
          "payable"
        ]
      },
      {
        "name": "do_add_relayer_key",
        "kind": "call",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "public_key",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        }
      },
      {
        "name": "do_auth_call",
        "kind": "view",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "signer_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "auth_call",
              "type_schema": {
                "$ref": "#/definitions/AuthCall"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Promise"
          }
        }
      },
      {
        "name": "do_ft_withdraw",
        "kind": "view",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "withdraw",
              "type_schema": {
                "$ref": "#/definitions/FtWithdraw"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Promise"
          }
        }
      },
      {
        "name": "do_mt_withdraw",
        "kind": "view",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "withdraw",
              "type_schema": {
                "$ref": "#/definitions/MtWithdraw"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Promise"
          }
        }
      },
      {
        "name": "do_native_withdraw",
        "kind": "view",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "withdraw",
              "type_schema": {
                "$ref": "#/definitions/NativeWithdraw"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Promise"
          }
        }
      },
      {
        "name": "do_nft_withdraw",
        "kind": "view",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "withdraw",
              "type_schema": {
                "$ref": "#/definitions/NftWithdraw"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Promise"
          }
        }
      },
      {
        "name": "do_storage_deposit",
        "kind": "view",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "storage_deposit",
              "type_schema": {
                "$ref": "#/definitions/StorageDeposit"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Promise"
          }
        }
      },
      {
        "name": "execute_intents",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "signed",
              "type_schema": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/MultiPayload"
                }
              }
            }
          ]
        }
      },
      {
        "name": "fee",
        "kind": "view",
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Pips"
          }
        }
      },
      {
        "name": "fee_collector",
        "kind": "view",
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
            "type": "string"
          }
        }
      },
      {
        "name": "force_add_public_keys",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "public_keys",
              "type_schema": {
                "type": "object",
                "additionalProperties": {
                  "type": "array",
                  "items": {
                    "examples": [
                      "ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
                      "secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"
                    ],
                    "type": "string",
                    "contentEncoding": "base58"
                  },
                  "uniqueItems": true
                }
              }
            }
          ]
        }
      },
      {
        "name": "force_disable_auth_by_predecessor_ids",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                }
              }
            }
          ]
        }
      },
      {
        "name": "force_enable_auth_by_predecessor_ids",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                }
              }
            }
          ]
        }
      },
      {
        "name": "force_lock_account",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "force_remove_public_keys",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "public_keys",
              "type_schema": {
                "type": "object",
                "additionalProperties": {
                  "type": "array",
                  "items": {
                    "examples": [
                      "ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
                      "secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"
                    ],
                    "type": "string",
                    "contentEncoding": "base58"
                  },
                  "uniqueItems": true
                }
              }
            }
          ]
        }
      },
      {
        "name": "force_unlock_account",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "ft_force_withdraw",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "owner_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "amount",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "memo",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            {
              "name": "msg",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueString"
          }
        }
      },
      {
        "name": "ft_on_transfer",
        "doc": " Deposit fungible tokens.\n\n `msg` contains [`AccountId`] of the internal recipient.\n Empty `msg` means deposit to `sender_id`",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "sender_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "amount",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "msg",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueString"
          }
        }
      },
      {
        "name": "ft_resolve_deposit",
        "kind": "call",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "contract_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "amount",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueString"
          }
        }
      },
      {
        "name": "ft_resolve_withdraw",
        "kind": "call",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "token",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "sender_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "amount",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "is_call",
              "type_schema": {
                "type": "boolean"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "string"
          }
        }
      },
      {
        "name": "ft_withdraw",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "token",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "amount",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "memo",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            {
              "name": "msg",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueString"
          }
        }
      },
      {
        "name": "has_public_key",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "public_key",
              "type_schema": {
                "examples": [
                  "ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
                  "secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"
                ],
                "type": "string",
                "contentEncoding": "base58"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "invalidate_salts",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "salts",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string",
                  "contentEncoding": "hex"
                }
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "string",
            "contentEncoding": "hex"
          }
        }
      },
      {
        "name": "is_account_locked",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "is_auth_by_predecessor_id_enabled",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "is_nonce_used",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "nonce",
              "type_schema": {
                "type": "string",
                "contentEncoding": "base64"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "is_valid_salt",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "salt",
              "type_schema": {
                "type": "string",
                "contentEncoding": "hex"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "mt_balance_of",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_id",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "string"
          }
        }
      },
      {
        "name": "mt_batch_balance_of",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "mt_batch_supply",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "token_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "array",
            "items": {
              "type": [
                "string",
                "null"
              ]
            }
          }
        }
      },
      {
        "name": "mt_batch_transfer",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "amounts",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "approvals",
              "type_schema": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": [
                    {
                      "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                      "type": "string"
                    },
                    {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    }
                  ],
                  "maxItems": 2,
                  "minItems": 2
                }
              }
            },
            {
              "name": "memo",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            }
          ]
        }
      },
      {
        "name": "mt_batch_transfer_call",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "amounts",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "approvals",
              "type_schema": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": [
                    {
                      "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                      "type": "string"
                    },
                    {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    }
                  ],
                  "maxItems": 2,
                  "minItems": 2
                }
              }
            },
            {
              "name": "memo",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            {
              "name": "msg",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueArray_of_String"
          }
        }
      },
      {
        "name": "mt_force_batch_transfer",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "owner_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "amounts",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "approvals",
              "type_schema": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": [
                    {
                      "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                      "type": "string"
                    },
                    {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    }
                  ],
                  "maxItems": 2,
                  "minItems": 2
                }
              }
            },
            {
              "name": "memo",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            }
          ]
        }
      },
      {
        "name": "mt_force_batch_transfer_call",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "owner_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "amounts",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "approvals",
              "type_schema": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": [
                    {
                      "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                      "type": "string"
                    },
                    {
                      "type": "integer",
                      "format": "uint64",
                      "minimum": 0.0
                    }
                  ],
                  "maxItems": 2,
                  "minItems": 2
                }
              }
            },
            {
              "name": "memo",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            {
              "name": "msg",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueArray_of_String"
          }
        }
      },
      {
        "name": "mt_force_transfer",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "owner_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_id",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "amount",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "approval",
              "type_schema": {
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                    "type": "string"
                  },
                  {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            {
              "name": "memo",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            }
          ]
        }
      },
      {
        "name": "mt_force_transfer_call",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "owner_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_id",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "amount",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "approval",
              "type_schema": {
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                    "type": "string"
                  },
                  {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            {
              "name": "memo",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            {
              "name": "msg",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueArray_of_String"
          }
        }
      },
      {
        "name": "mt_force_withdraw",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "owner_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "amounts",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "memo",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            {
              "name": "msg",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueArray_of_String"
          }
        }
      },
      {
        "name": "mt_on_transfer",
        "doc": " Deposit multi-tokens.\n\n `msg` contains [`AccountId`] of the internal recipient.\n Empty `msg` means deposit to `sender_id`",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "sender_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "previous_owner_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                }
              }
            },
            {
              "name": "token_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "amounts",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "msg",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueArray_of_String"
          }
        }
      },
      {
        "name": "mt_resolve_deposit",
        "kind": "call",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "contract_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "tokens",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "amounts",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueArray_of_String"
          }
        }
      },
      {
        "name": "mt_resolve_transfer",
        "kind": "call",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "previous_owner_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                }
              }
            },
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "amounts",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "approvals",
              "type_schema": {
                "type": [
                  "array",
                  "null"
                ],
                "items": {
                  "type": [
                    "array",
                    "null"
                  ],
                  "items": {
                    "type": "array",
                    "items": [
                      {
                        "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                        "type": "string"
                      },
                      {
                        "type": "integer",
                        "format": "uint64",
                        "minimum": 0.0
                      },
                      {
                        "type": "string"
                      }
                    ],
                    "maxItems": 3,
                    "minItems": 3
                  }
                }
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "mt_resolve_withdraw",
        "kind": "call",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "token",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "sender_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "amounts",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "is_call",
              "type_schema": {
                "type": "boolean"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      {
        "name": "mt_supply",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "token_id",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": [
              "string",
              "null"
            ]
          }
        }
      },
      {
        "name": "mt_token",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "token_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Token"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        }
      },
      {
        "name": "mt_tokens",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "from_index",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            {
              "name": "limit",
              "type_schema": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Token"
            }
          }
        }
      },
      {
        "name": "mt_tokens_for_owner",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "from_index",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            {
              "name": "limit",
              "type_schema": {
                "type": [
                  "integer",
                  "null"
                ],
                "format": "uint32",
                "minimum": 0.0
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "array",
            "items": {
              "$ref": "#/definitions/Token"
            }
          }
        }
      },
      {
        "name": "mt_transfer",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_id",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "amount",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "approval",
              "type_schema": {
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                    "type": "string"
                  },
                  {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            {
              "name": "memo",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            }
          ]
        }
      },
      {
        "name": "mt_transfer_call",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_id",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "amount",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "approval",
              "type_schema": {
                "type": [
                  "array",
                  "null"
                ],
                "items": [
                  {
                    "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                    "type": "string"
                  },
                  {
                    "type": "integer",
                    "format": "uint64",
                    "minimum": 0.0
                  }
                ],
                "maxItems": 2,
                "minItems": 2
              }
            },
            {
              "name": "memo",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            {
              "name": "msg",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueArray_of_String"
          }
        }
      },
      {
        "name": "mt_withdraw",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "token",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_ids",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "amounts",
              "type_schema": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            {
              "name": "memo",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            {
              "name": "msg",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueArray_of_String"
          }
        }
      },
      {
        "name": "new",
        "kind": "call",
        "modifiers": [
          "init"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "config",
              "type_schema": {
                "$ref": "#/definitions/DefuseConfig"
              }
            }
          ]
        }
      },
      {
        "name": "nft_force_withdraw",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "owner_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_id",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "memo",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            {
              "name": "msg",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueBoolean"
          }
        }
      },
      {
        "name": "nft_on_transfer",
        "doc": " Deposit non-fungible token.\n\n `msg` contains [`AccountId`] of the internal recipient.\n Empty `msg` means deposit to `sender_id`",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "sender_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "previous_owner_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_id",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "msg",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueBoolean"
          }
        }
      },
      {
        "name": "nft_resolve_deposit",
        "kind": "call",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "contract_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "nft_token_id",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueBoolean"
          }
        }
      },
      {
        "name": "nft_resolve_withdraw",
        "kind": "call",
        "modifiers": [
          "private"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "token",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "sender_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_id",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "is_call",
              "type_schema": {
                "type": "boolean"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "nft_withdraw",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "token",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "receiver_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            {
              "name": "token_id",
              "type_schema": {
                "type": "string"
              }
            },
            {
              "name": "memo",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            },
            {
              "name": "msg",
              "type_schema": {
                "type": [
                  "string",
                  "null"
                ]
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/PromiseOrValueBoolean"
          }
        }
      },
      {
        "name": "pa_all_paused",
        "kind": "view",
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": [
              "array",
              "null"
            ],
            "items": {
              "type": "string"
            },
            "uniqueItems": true
          }
        }
      },
      {
        "name": "pa_is_paused",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "key",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "pa_pause_feature",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "key",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "pa_storage_key",
        "kind": "view",
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "array",
            "items": {
              "type": "integer",
              "format": "uint8",
              "minimum": 0.0
            }
          }
        }
      },
      {
        "name": "pa_unpause_feature",
        "kind": "call",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "key",
              "type_schema": {
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "boolean"
          }
        }
      },
      {
        "name": "public_keys_of",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "account_id",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "array",
            "items": {
              "examples": [
                "ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
                "secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"
              ],
              "type": "string",
              "contentEncoding": "base58"
            },
            "uniqueItems": true
          }
        }
      },
      {
        "name": "remove_public_key",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "public_key",
              "type_schema": {
                "examples": [
                  "ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
                  "secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"
                ],
                "type": "string",
                "contentEncoding": "base58"
              }
            }
          ]
        }
      },
      {
        "name": "set_fee",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "fee",
              "type_schema": {
                "$ref": "#/definitions/Pips"
              }
            }
          ]
        }
      },
      {
        "name": "set_fee_collector",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "fee_collector",
              "type_schema": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          ]
        }
      },
      {
        "name": "simulate_intents",
        "kind": "view",
        "params": {
          "serialization_type": "json",
          "args": [
            {
              "name": "signed",
              "type_schema": {
                "type": "array",
                "items": {
                  "$ref": "#/definitions/MultiPayload"
                }
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/SimulationOutput"
          }
        }
      },
      {
        "name": "state_migrate",
        "kind": "call",
        "modifiers": [
          "private"
        ]
      },
      {
        "name": "update_current_salt",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "type": "string",
            "contentEncoding": "hex"
          }
        }
      },
      {
        "name": "upgrade",
        "kind": "call",
        "modifiers": [
          "payable"
        ],
        "params": {
          "serialization_type": "borsh",
          "args": [
            {
              "name": "code",
              "type_schema": {
                "declaration": "Vec<u8>",
                "definitions": {
                  "Vec<u8>": {
                    "Sequence": {
                      "length_width": 4,
                      "length_range": {
                        "start": 0,
                        "end": 4294967295
                      },
                      "elements": "u8"
                    }
                  },
                  "u8": {
                    "Primitive": 1
                  }
                }
              }
            },
            {
              "name": "state_migration_gas",
              "type_schema": {
                "declaration": "Option<NearGas>",
                "definitions": {
                  "()": {
                    "Primitive": 0
                  },
                  "NearGas": {
                    "Struct": [
                      [
                        "inner",
                        "u64"
                      ]
                    ]
                  },
                  "Option<NearGas>": {
                    "Enum": {
                      "tag_width": 1,
                      "variants": [
                        [
                          0,
                          "None",
                          "()"
                        ],
                        [
                          1,
                          "Some",
                          "NearGas"
                        ]
                      ]
                    }
                  },
                  "u64": {
                    "Primitive": 8
                  }
                }
              }
            }
          ]
        },
        "result": {
          "serialization_type": "json",
          "type_schema": {
            "$ref": "#/definitions/Promise"
          }
        }
      }
    ],
    "root_schema": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "String",
      "type": "string",
      "definitions": {
        "AbiHelper": {
          "type": "object",
          "required": [
            "intent",
            "payload"
          ],
          "properties": {
            "intent": {
              "$ref": "#/definitions/Intent"
            },
            "payload": {
              "$ref": "#/definitions/AbiPayloadHelper"
            }
          }
        },
        "AbiPayloadHelper": {
          "type": "object",
          "required": [
            "defuse",
            "nep413"
          ],
          "properties": {
            "defuse": {
              "$ref": "#/definitions/DefusePayload_for_DefuseIntents"
            },
            "nep413": {
              "$ref": "#/definitions/Nep413DefuseMessage_for_DefuseIntents"
            }
          }
        },
        "AuthCall": {
          "description": "Call [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) with `signer_id` of intent.",
          "type": "object",
          "required": [
            "contract_id",
            "msg"
          ],
          "properties": {
            "attached_deposit": {
              "description": "Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
              "type": "string"
            },
            "contract_id": {
              "description": "Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
              "type": "string"
            },
            "min_gas": {
              "description": "Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
              "type": [
                "string",
                "null"
              ]
            },
            "msg": {
              "description": "`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
              "type": "string"
            },
            "state_init": {
              "description": "Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
              "anyOf": [
                {
                  "$ref": "#/definitions/StateInit"
                },
                {
                  "type": "null"
                }
              ]
            }
          }
        },
        "Deadline": {
          "type": "string"
        },
        "DefuseConfig": {
          "type": "object",
          "required": [
            "fees",
            "wnear_id"
          ],
          "properties": {
            "fees": {
              "$ref": "#/definitions/FeesConfig"
            },
            "roles": {
              "default": {
                "admins": {},
                "grantees": {},
                "super_admins": []
              },
              "allOf": [
                {
                  "$ref": "#/definitions/RolesConfig"
                }
              ]
            },
            "wnear_id": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            }
          }
        },
        "DefusePayload_for_DefuseIntents": {
          "type": "object",
          "required": [
            "deadline",
            "nonce",
            "signer_id",
            "verifying_contract"
          ],
          "properties": {
            "deadline": {
              "$ref": "#/definitions/Deadline"
            },
            "intents": {
              "description": "Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
              "type": "array",
              "items": {
                "$ref": "#/definitions/Intent"
              }
            },
            "nonce": {
              "examples": [
                "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
              ],
              "type": "string",
              "contentEncoding": "base64"
            },
            "signer_id": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            },
            "verifying_contract": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            }
          }
        },
        "Erc191Payload": {
          "description": "See [ERC-191](https://github.com/ethereum/ercs/blob/master/ERCS/erc-191.md)",
          "type": "string"
        },
        "FeesConfig": {
          "type": "object",
          "required": [
            "fee",
            "fee_collector"
          ],
          "properties": {
            "fee": {
              "$ref": "#/definitions/Pips"
            },
            "fee_collector": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            }
          }
        },
        "FtWithdraw": {
          "description": "Withdraw given FT tokens from the intents contract to a given external account id (external being outside of intents).",
          "type": "object",
          "required": [
            "amount",
            "receiver_id",
            "token"
          ],
          "properties": {
            "amount": {
              "type": "string"
            },
            "memo": {
              "type": [
                "string",
                "null"
              ]
            },
            "min_gas": {
              "description": "Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
              "type": [
                "string",
                "null"
              ]
            },
            "msg": {
              "description": "Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
              "type": [
                "string",
                "null"
              ]
            },
            "receiver_id": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            },
            "storage_deposit": {
              "description": "Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
              "type": [
                "string",
                "null"
              ]
            },
            "token": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            }
          }
        },
        "GlobalContractId": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "hash"
              ],
              "properties": {
                "hash": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            },
            {
              "type": "object",
              "required": [
                "account_id"
              ],
              "properties": {
                "account_id": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          ]
        },
        "Intent": {
          "oneOf": [
            {
              "description": "See [`AddPublicKey`]",
              "type": "object",
              "required": [
                "intent",
                "public_key"
              ],
              "properties": {
                "intent": {
                  "type": "string",
                  "enum": [
                    "add_public_key"
                  ]
                },
                "public_key": {
                  "examples": [
                    "ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
                    "secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"
                  ],
                  "type": "string",
                  "contentEncoding": "base58"
                }
              }
            },
            {
              "description": "See [`RemovePublicKey`]",
              "type": "object",
              "required": [
                "intent",
                "public_key"
              ],
              "properties": {
                "intent": {
                  "type": "string",
                  "enum": [
                    "remove_public_key"
                  ]
                },
                "public_key": {
                  "examples": [
                    "ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
                    "secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"
                  ],
                  "type": "string",
                  "contentEncoding": "base58"
                }
              }
            },
            {
              "description": "See [`Transfer`]",
              "type": "object",
              "required": [
                "intent",
                "receiver_id",
                "tokens"
              ],
              "properties": {
                "intent": {
                  "type": "string",
                  "enum": [
                    "transfer"
                  ]
                },
                "memo": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "min_gas": {
                  "description": "Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "msg": {
                  "description": "Message to pass to `mt_on_transfer`",
                  "type": "string"
                },
                "receiver_id": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                },
                "state_init": {
                  "description": "Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
                  "anyOf": [
                    {
                      "$ref": "#/definitions/StateInit"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "tokens": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            {
              "description": "See [`FtWithdraw`]",
              "type": "object",
              "required": [
                "amount",
                "intent",
                "receiver_id",
                "token"
              ],
              "properties": {
                "amount": {
                  "type": "string"
                },
                "intent": {
                  "type": "string",
                  "enum": [
                    "ft_withdraw"
                  ]
                },
                "memo": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "min_gas": {
                  "description": "Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "msg": {
                  "description": "Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "receiver_id": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                },
                "storage_deposit": {
                  "description": "Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "token": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                }
              }
            },
            {
              "description": "See [`NftWithdraw`]",
              "type": "object",
              "required": [
                "intent",
                "receiver_id",
                "token",
                "token_id"
              ],
              "properties": {
                "intent": {
                  "type": "string",
                  "enum": [
                    "nft_withdraw"
                  ]
                },
                "memo": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "min_gas": {
                  "description": "Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "msg": {
                  "description": "Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "receiver_id": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                },
                "storage_deposit": {
                  "description": "Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "token": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                },
                "token_id": {
                  "type": "string"
                }
              }
            },
            {
              "description": "See [`MtWithdraw`]",
              "type": "object",
              "required": [
                "amounts",
                "intent",
                "receiver_id",
                "token",
                "token_ids"
              ],
              "properties": {
                "amounts": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "intent": {
                  "type": "string",
                  "enum": [
                    "mt_withdraw"
                  ]
                },
                "memo": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "min_gas": {
                  "description": "Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "msg": {
                  "description": "Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "receiver_id": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                },
                "storage_deposit": {
                  "description": "Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "token": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                },
                "token_ids": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            },
            {
              "description": "See [`NativeWithdraw`]",
              "type": "object",
              "required": [
                "amount",
                "intent",
                "receiver_id"
              ],
              "properties": {
                "amount": {
                  "type": "string"
                },
                "intent": {
                  "type": "string",
                  "enum": [
                    "native_withdraw"
                  ]
                },
                "receiver_id": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                }
              }
            },
            {
              "description": "See [`StorageDeposit`]",
              "type": "object",
              "required": [
                "amount",
                "contract_id",
                "deposit_for_account_id",
                "intent"
              ],
              "properties": {
                "amount": {
                  "type": "string"
                },
                "contract_id": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                },
                "deposit_for_account_id": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                },
                "intent": {
                  "type": "string",
                  "enum": [
                    "storage_deposit"
                  ]
                }
              }
            },
            {
              "description": "See [`TokenDiff`]",
              "type": "object",
              "required": [
                "diff",
                "intent"
              ],
              "properties": {
                "diff": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "intent": {
                  "type": "string",
                  "enum": [
                    "token_diff"
                  ]
                },
                "memo": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "referral": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": [
                    "string",
                    "null"
                  ]
                }
              }
            },
            {
              "description": "See [`SetAuthByPredecessorId`]",
              "type": "object",
              "required": [
                "enabled",
                "intent"
              ],
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "intent": {
                  "type": "string",
                  "enum": [
                    "set_auth_by_predecessor_id"
                  ]
                }
              }
            },
            {
              "description": "See [`AuthCall`]",
              "type": "object",
              "required": [
                "contract_id",
                "intent",
                "msg"
              ],
              "properties": {
                "attached_deposit": {
                  "description": "Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
                  "type": "string"
                },
                "contract_id": {
                  "description": "Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
                  "type": "string"
                },
                "intent": {
                  "type": "string",
                  "enum": [
                    "auth_call"
                  ]
                },
                "min_gas": {
                  "description": "Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "msg": {
                  "description": "`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
                  "type": "string"
                },
                "state_init": {
                  "description": "Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
                  "anyOf": [
                    {
                      "$ref": "#/definitions/StateInit"
                    },
                    {
                      "type": "null"
                    }
                  ]
                }
              }
            },
            {
              "description": "Mint a set of tokens from the signer to a specified account id, within the intents contract.",
              "type": "object",
              "required": [
                "intent",
                "receiver_id",
                "tokens"
              ],
              "properties": {
                "intent": {
                  "type": "string",
                  "enum": [
                    "imt_mint"
                  ]
                },
                "memo": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "min_gas": {
                  "description": "Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "msg": {
                  "description": "Message to pass to `mt_on_transfer`",
                  "type": "string"
                },
                "receiver_id": {
                  "description": "Receiver of the minted tokens",
                  "type": "string"
                },
                "state_init": {
                  "description": "Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
                  "anyOf": [
                    {
                      "$ref": "#/definitions/StateInit"
                    },
                    {
                      "type": "null"
                    }
                  ]
                },
                "tokens": {
                  "description": "The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            {
              "description": "Burn a set of imt tokens, within the intents contract.",
              "type": "object",
              "required": [
                "intent",
                "minter_id",
                "tokens"
              ],
              "properties": {
                "intent": {
                  "type": "string",
                  "enum": [
                    "imt_burn"
                  ]
                },
                "memo": {
                  "type": [
                    "string",
                    "null"
                  ]
                },
                "minter_id": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                },
                "tokens": {
                  "description": "The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            }
          ]
        },
        "IntentEvent_for_AccountEvent_for_NonceEvent": {
          "type": "object",
          "required": [
            "account_id",
            "intent_hash",
            "nonce"
          ],
          "properties": {
            "account_id": {
              "description": "Account identifier. This is the human readable UTF-8 string which is used internally to index accounts on the network and their respective state.\n\nThis is the \"referenced\" version of the account ID. It is to [`AccountId`] what [`str`] is to [`String`], and works quite similarly to [`Path`]. Like with [`str`] and [`Path`], you can't have a value of type `AccountIdRef`, but you can have a reference like `&AccountIdRef` or `&mut AccountIdRef`.\n\nThis type supports zero-copy deserialization offered by [`serde`](https://docs.rs/serde/), but cannot do the same for [`borsh`](https://docs.rs/borsh/) since the latter does not support zero-copy.\n\n# Examples ``` use near_account_id::{AccountId, AccountIdRef}; use std::convert::{TryFrom, TryInto};\n\n// Construction let alice = AccountIdRef::new(\"alice.near\").unwrap(); assert!(AccountIdRef::new(\"invalid.\").is_err()); ```\n\n[`FromStr`]: std::str::FromStr [`Path`]: std::path::Path",
              "type": "string"
            },
            "intent_hash": {
              "type": "string",
              "contentEncoding": "base58"
            },
            "nonce": {
              "type": "string",
              "contentEncoding": "base64"
            }
          }
        },
        "InvariantViolated": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "error",
                "unmatched_deltas"
              ],
              "properties": {
                "error": {
                  "type": "string",
                  "enum": [
                    "unmatched_deltas"
                  ]
                },
                "unmatched_deltas": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            },
            {
              "type": "object",
              "required": [
                "error"
              ],
              "properties": {
                "error": {
                  "type": "string",
                  "enum": [
                    "overflow"
                  ]
                }
              }
            }
          ]
        },
        "MtWithdraw": {
          "description": "Withdraw given MT tokens (i.e. [NEP-245](https://github.com/near/NEPs/blob/master/neps/nep-0245.md)) from the intents contract to a given to an external account id (external being outside of intents).\n\nIf `msg` is given, `mt_batch_transfer_call()` will be used to transfer to the `receiver_id`. Otherwise, `mt_batch_transfer()` will be used.",
          "type": "object",
          "required": [
            "amounts",
            "receiver_id",
            "token",
            "token_ids"
          ],
          "properties": {
            "amounts": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "memo": {
              "type": [
                "string",
                "null"
              ]
            },
            "min_gas": {
              "description": "Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
              "type": [
                "string",
                "null"
              ]
            },
            "msg": {
              "description": "Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
              "type": [
                "string",
                "null"
              ]
            },
            "receiver_id": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            },
            "storage_deposit": {
              "description": "Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
              "type": [
                "string",
                "null"
              ]
            },
            "token": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            },
            "token_ids": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "MultiPayload": {
          "description": "Assuming wallets want to interact with Intents protocol, besides preparing the data in a certain form, they have to have the capability to sign raw messages (off-chain signatures) using an algorithm we understand. This enum solves that problem.\n\nFor example, because we support ERC-191 and know how to verify messages with that standard, we can allow wallets, like Metamask, sign messages to perform intents without having to support new cryptographic primitives and signing standards.",
          "oneOf": [
            {
              "description": "NEP-413: The standard for message signing in Near Protocol. For more details, refer to [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md).",
              "type": "object",
              "required": [
                "payload",
                "public_key",
                "signature",
                "standard"
              ],
              "properties": {
                "payload": {
                  "$ref": "#/definitions/Nep413Payload"
                },
                "public_key": {
                  "type": "string",
                  "pattern": "^ed25519:",
                  "contentEncoding": "base58"
                },
                "signature": {
                  "type": "string",
                  "pattern": "^ed25519:",
                  "contentEncoding": "base58"
                },
                "standard": {
                  "type": "string",
                  "enum": [
                    "nep413"
                  ]
                }
              }
            },
            {
              "description": "ERC-191: The standard for message signing in Ethereum, commonly used with `personal_sign()`. For more details, refer to [EIP-191](https://eips.ethereum.org/EIPS/eip-191).",
              "type": "object",
              "required": [
                "payload",
                "signature",
                "standard"
              ],
              "properties": {
                "payload": {
                  "$ref": "#/definitions/Erc191Payload"
                },
                "signature": {
                  "description": "There is no public key member because the public key can be recovered via `ecrecover()` knowing the data and the signature",
                  "type": "string",
                  "pattern": "^secp256k1:",
                  "contentEncoding": "base58"
                },
                "standard": {
                  "type": "string",
                  "enum": [
                    "erc191"
                  ]
                }
              }
            },
            {
              "description": "TIP-191: The standard for message signing in Tron. For more details, refer to [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md).",
              "type": "object",
              "required": [
                "payload",
                "signature",
                "standard"
              ],
              "properties": {
                "payload": {
                  "$ref": "#/definitions/Tip191Payload"
                },
                "signature": {
                  "description": "There is no public key member because the public key can be recovered via `ecrecover()` knowing the data and the signature",
                  "type": "string",
                  "pattern": "^secp256k1:",
                  "contentEncoding": "base58"
                },
                "standard": {
                  "type": "string",
                  "enum": [
                    "tip191"
                  ]
                }
              }
            },
            {
              "description": "Raw Ed25519: The standard used by Solana Phantom wallets for message signing. For more details, refer to [Phantom Wallet's documentation](https://docs.phantom.com/solana/signing-a-message).",
              "type": "object",
              "required": [
                "payload",
                "public_key",
                "signature",
                "standard"
              ],
              "properties": {
                "payload": {
                  "type": "string"
                },
                "public_key": {
                  "type": "string",
                  "pattern": "^ed25519:",
                  "contentEncoding": "base58"
                },
                "signature": {
                  "type": "string",
                  "pattern": "^ed25519:",
                  "contentEncoding": "base58"
                },
                "standard": {
                  "type": "string",
                  "enum": [
                    "raw_ed25519"
                  ]
                }
              }
            },
            {
              "description": "WebAuthn: The standard for Passkeys. For more details, refer to [WebAuthn specification](https://w3c.github.io/webauthn/).",
              "type": "object",
              "anyOf": [
                {
                  "description": "[COSE EdDSA (-8) algorithm](https://www.iana.org/assignments/cose/cose.xhtml#algorithms): ed25519 curve",
                  "type": "object",
                  "required": [
                    "public_key",
                    "signature"
                  ],
                  "properties": {
                    "public_key": {
                      "type": "string",
                      "pattern": "^ed25519:",
                      "contentEncoding": "base58"
                    },
                    "signature": {
                      "type": "string",
                      "pattern": "^ed25519:",
                      "contentEncoding": "base58"
                    }
                  }
                },
                {
                  "description": "[COSE ES256 (-7) algorithm](https://www.iana.org/assignments/cose/cose.xhtml#algorithms): NIST P-256 curve (a.k.a secp256r1) over SHA-256",
                  "type": "object",
                  "required": [
                    "public_key",
                    "signature"
                  ],
                  "properties": {
                    "public_key": {
                      "type": "string",
                      "pattern": "^p256:",
                      "contentEncoding": "base58"
                    },
                    "signature": {
                      "type": "string",
                      "pattern": "^p256:",
                      "contentEncoding": "base58"
                    }
                  }
                }
              ],
              "required": [
                "authenticator_data",
                "client_data_json",
                "payload",
                "standard"
              ],
              "properties": {
                "authenticator_data": {
                  "description": "Base64Url-encoded [authenticatorData](https://w3c.github.io/webauthn/#authenticator-data)",
                  "type": "string",
                  "contentEncoding": "base64"
                },
                "client_data_json": {
                  "description": "Serialized [clientDataJSON](https://w3c.github.io/webauthn/#dom-authenticatorresponse-clientdatajson)",
                  "type": "string"
                },
                "payload": {
                  "type": "string"
                },
                "standard": {
                  "type": "string",
                  "enum": [
                    "webauthn"
                  ]
                }
              }
            },
            {
              "description": "TonConnect: The standard for data signing in TON blockchain platform. For more details, refer to [TonConnect documentation](https://docs.tonconsole.com/academy/sign-data).",
              "type": "object",
              "required": [
                "address",
                "domain",
                "payload",
                "public_key",
                "signature",
                "standard",
                "timestamp"
              ],
              "properties": {
                "address": {
                  "description": "Wallet address in either [Raw](https://docs.ton.org/v3/documentation/smart-contracts/addresses/address-formats#raw-address) representation or [user-friendly](https://docs.ton.org/v3/documentation/smart-contracts/addresses/address-formats#user-friendly-address) format",
                  "allOf": [
                    {
                      "$ref": "#/definitions/String"
                    }
                  ]
                },
                "domain": {
                  "description": "dApp domain",
                  "type": "string"
                },
                "payload": {
                  "$ref": "#/definitions/TonConnectPayloadSchema"
                },
                "public_key": {
                  "type": "string",
                  "pattern": "^ed25519:",
                  "contentEncoding": "base58"
                },
                "signature": {
                  "type": "string",
                  "pattern": "^ed25519:",
                  "contentEncoding": "base58"
                },
                "standard": {
                  "type": "string",
                  "enum": [
                    "ton_connect"
                  ]
                },
                "timestamp": {
                  "description": "UNIX timestamp (in seconds or RFC3339) at the time of singing",
                  "allOf": [
                    {
                      "$ref": "#/definitions/PickFirst(DateTimeint64)"
                    }
                  ]
                }
              }
            },
            {
              "description": "SEP-53: The standard for signing data off-chain for Stellar accounts. See [SEP-53](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0053.md)",
              "type": "object",
              "required": [
                "payload",
                "public_key",
                "signature",
                "standard"
              ],
              "properties": {
                "payload": {
                  "type": "string"
                },
                "public_key": {
                  "type": "string",
                  "pattern": "^ed25519:",
                  "contentEncoding": "base58"
                },
                "signature": {
                  "type": "string",
                  "pattern": "^ed25519:",
                  "contentEncoding": "base58"
                },
                "standard": {
                  "type": "string",
                  "enum": [
                    "sep53"
                  ]
                }
              }
            }
          ]
        },
        "NativeWithdraw": {
          "description": "Withdraw native tokens (NEAR) from the intents contract to a given external account id (external being outside of intents). This will subtract from the account's wNEAR balance, and will be sent to the account specified as native NEAR. NOTE: the `wNEAR` will not be refunded in case of fail (e.g. `receiver_id` account does not exist).",
          "type": "object",
          "required": [
            "amount",
            "receiver_id"
          ],
          "properties": {
            "amount": {
              "type": "string"
            },
            "receiver_id": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            }
          }
        },
        "Nep413DefuseMessage_for_DefuseIntents": {
          "type": "object",
          "required": [
            "deadline",
            "signer_id"
          ],
          "properties": {
            "deadline": {
              "$ref": "#/definitions/Deadline"
            },
            "intents": {
              "description": "Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
              "type": "array",
              "items": {
                "$ref": "#/definitions/Intent"
              }
            },
            "signer_id": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            }
          }
        },
        "Nep413Payload": {
          "description": "See [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)",
          "type": "object",
          "required": [
            "message",
            "nonce",
            "recipient"
          ],
          "properties": {
            "callbackUrl": {
              "type": [
                "string",
                "null"
              ]
            },
            "message": {
              "type": "string"
            },
            "nonce": {
              "type": "string",
              "contentEncoding": "base64"
            },
            "recipient": {
              "type": "string"
            }
          }
        },
        "NftWithdraw": {
          "description": "Withdraw given NFT tokens from the intents contract to a given external account id (external being outside of intents).",
          "type": "object",
          "required": [
            "receiver_id",
            "token",
            "token_id"
          ],
          "properties": {
            "memo": {
              "type": [
                "string",
                "null"
              ]
            },
            "min_gas": {
              "description": "Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
              "type": [
                "string",
                "null"
              ]
            },
            "msg": {
              "description": "Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
              "type": [
                "string",
                "null"
              ]
            },
            "receiver_id": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            },
            "storage_deposit": {
              "description": "Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
              "type": [
                "string",
                "null"
              ]
            },
            "token": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            },
            "token_id": {
              "type": "string"
            }
          }
        },
        "PermissionedAccounts": {
          "description": "Collects super admin accounts and accounts that have been granted permissions defined by `AccessControlRole`.\n\n# Data structure\n\nAssume `AccessControlRole` is derived for the following enum, which is then passed as `role` attribute to `AccessControllable`.\n\n```rust pub enum Role { PauseManager, UnpauseManager, } ```\n\nThen the returned data has the following structure:\n\n```ignore PermissionedAccounts { super_admins: vec![\"acc1.near\", \"acc2.near\"], roles: HashMap::from([ (\"PauseManager\", PermissionedAccountsPerRole { admins: vec![\"acc3.near\", \"acc4.near\"], grantees: vec![\"acc5.near\", \"acc6.near\"], }), (\"UnpauseManager\", PermissionedAccountsPerRole { admins: vec![\"acc7.near\", \"acc8.near\"], grantees: vec![\"acc9.near\", \"acc10.near\"], }), ]) } ```\n\n# Uniqueness and ordering\n\nAccount ids returned in vectors are unique but not ordered.",
          "type": "object",
          "required": [
            "roles",
            "super_admins"
          ],
          "properties": {
            "roles": {
              "description": "The admins and grantees of all roles.",
              "type": "object",
              "additionalProperties": {
                "$ref": "#/definitions/PermissionedAccountsPerRole"
              }
            },
            "super_admins": {
              "description": "The accounts that have super admin permissions.",
              "type": "array",
              "items": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          }
        },
        "PermissionedAccountsPerRole": {
          "description": "Collects all admins and grantees of a role.\n\n# Uniqueness and ordering\n\nAccount ids returned in vectors are unique but not ordered.",
          "type": "object",
          "required": [
            "admins",
            "grantees"
          ],
          "properties": {
            "admins": {
              "description": "The accounts that have admin permissions for the role.",
              "type": "array",
              "items": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            },
            "grantees": {
              "description": "The accounts that have been granted the role.",
              "type": "array",
              "items": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              }
            }
          }
        },
        "PickFirst(DateTimeint64)": {
          "anyOf": [
            {
              "type": "string",
              "format": "date-time"
            },
            {
              "writeOnly": true,
              "allOf": [
                {
                  "type": "integer",
                  "format": "int64"
                }
              ]
            }
          ]
        },
        "Pips": {
          "description": "1 pip == 1/100th of bip == 0.0001%",
          "type": "integer",
          "format": "uint32",
          "minimum": 0.0
        },
        "Promise": true,
        "PromiseOrValueArray_of_String": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "PromiseOrValueBoolean": {
          "type": "boolean"
        },
        "PromiseOrValueString": {
          "type": "string"
        },
        "RolesConfig": {
          "type": "object",
          "properties": {
            "admins": {
              "default": {},
              "type": "object",
              "additionalProperties": {
                "type": "array",
                "items": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                },
                "uniqueItems": true
              }
            },
            "grantees": {
              "default": {},
              "type": "object",
              "additionalProperties": {
                "type": "array",
                "items": {
                  "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                  "type": "string"
                },
                "uniqueItems": true
              }
            },
            "super_admins": {
              "default": [],
              "type": "array",
              "items": {
                "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
                "type": "string"
              },
              "uniqueItems": true
            }
          }
        },
        "SimulationOutput": {
          "type": "object",
          "required": [
            "intents_executed",
            "logs",
            "min_deadline",
            "state"
          ],
          "properties": {
            "intents_executed": {
              "type": "array",
              "items": {
                "$ref": "#/definitions/IntentEvent_for_AccountEvent_for_NonceEvent"
              }
            },
            "invariant_violated": {
              "description": "Unmatched token deltas needed to keep the invariant. If not empty, can be used along with fee to calculate `token_diff` closure.",
              "anyOf": [
                {
                  "$ref": "#/definitions/InvariantViolated"
                },
                {
                  "type": "null"
                }
              ]
            },
            "logs": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "min_deadline": {
              "$ref": "#/definitions/Deadline"
            },
            "state": {
              "description": "Additional info about current state",
              "allOf": [
                {
                  "$ref": "#/definitions/StateOutput"
                }
              ]
            }
          }
        },
        "StateInit": {
          "oneOf": [
            {
              "type": "object",
              "required": [
                "code",
                "data",
                "version"
              ],
              "properties": {
                "code": {
                  "$ref": "#/definitions/GlobalContractId"
                },
                "data": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "version": {
                  "type": "string",
                  "enum": [
                    "v1"
                  ]
                }
              }
            }
          ]
        },
        "StateOutput": {
          "type": "object",
          "required": [
            "current_salt",
            "fee"
          ],
          "properties": {
            "current_salt": {
              "type": "string",
              "contentEncoding": "hex"
            },
            "fee": {
              "$ref": "#/definitions/Pips"
            }
          }
        },
        "StorageDeposit": {
          "description": "Make [NEP-145](https://nomicon.io/Standards/StorageManagement#nep-145) `storage_deposit` for an `account_id` on `contract_id`. The `amount` will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in any case.\n\nWARNING: use this intent only if paying storage_deposit is not a prerequisite for other intents to succeed. If some intent (e.g. ft_withdraw) requires storage_deposit, then use storage_deposit field of corresponding intent instead of adding a separate `StorageDeposit` intent. This is due to the fact that intents that fire `Promise`s are not guaranteed to be executed sequentially, in the order of the provided intents in `DefuseIntents`.",
          "type": "object",
          "required": [
            "amount",
            "contract_id",
            "deposit_for_account_id"
          ],
          "properties": {
            "amount": {
              "type": "string"
            },
            "contract_id": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            },
            "deposit_for_account_id": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": "string"
            }
          }
        },
        "String": {
          "type": "string"
        },
        "Tip191Payload": {
          "description": "See [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md)",
          "type": "string"
        },
        "Token": {
          "type": "object",
          "required": [
            "token_id"
          ],
          "properties": {
            "owner_id": {
              "description": "NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = \"alice.near\".parse().unwrap();\n\nassert!(\"ƒelicia.near\".parse::<AccountId>().is_err()); // (ƒ is not f) ```",
              "type": [
                "string",
                "null"
              ]
            },
            "token_id": {
              "type": "string"
            }
          }
        },
        "TonConnectPayloadSchema": {
          "description": "See <https://docs.tonconsole.com/academy/sign-data#choosing-the-right-format>",
          "oneOf": [
            {
              "type": "object",
              "required": [
                "text",
                "type"
              ],
              "properties": {
                "text": {
                  "type": "string"
                },
                "type": {
                  "type": "string",
                  "enum": [
                    "text"
                  ]
                }
              }
            }
          ]
        }
      }
    }
  }
}