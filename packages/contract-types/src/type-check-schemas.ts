/**
 * This file was automatically generated by gen-defuse-types.ts.
 * DO NOT MODIFY IT BY HAND.
 *
 * This file provides compile-time type checking for schemas using JSONSchemaType.
 * It is NOT included in the bundle - it's only used during development for type safety.
 * The actual runtime validation uses validate.ts which has optimized JSON.parse loading.
 */

import type { JSONSchemaType } from "ajv";
import type * as Types from "./index.js";

export const AuthCallSchema: JSONSchemaType<Types.AuthCall> = {
	description:
		"Call [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) with `signer_id` of intent.",
	type: "object",
	required: ["contract_id", "msg"],
	properties: {
		attached_deposit: {
			description:
				"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
			type: "string",
			nullable: true,
		},
		contract_id: {
			description:
				"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
			type: "string",
		},
		min_gas: {
			description:
				"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
			type: "string",
			nullable: true,
		},
		msg: {
			description:
				"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
			type: "string",
		},
		state_init: {
			description:
				"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
			oneOf: [
				{
					type: "object",
					required: ["code", "data", "version"],
					properties: {
						code: {
							oneOf: [
								{
									type: "object",
									required: ["hash"],
									properties: { hash: { type: "string" } },
									additionalProperties: false,
								},
								{
									type: "object",
									required: ["account_id"],
									properties: {
										account_id: {
											description:
												'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
											type: "string",
										},
									},
									additionalProperties: false,
								},
							],
						},
						data: {
							type: "object",
							additionalProperties: { type: "string" },
							required: [],
						},
						version: { type: "string", enum: ["v1"] },
					},
					additionalProperties: false,
				},
				{ type: "null" },
			],
		},
	},
	additionalProperties: false,
};

export const DeadlineSchema: JSONSchemaType<Types.Deadline> = {
	type: "string",
};

export const DefuseConfigSchema: JSONSchemaType<Types.DefuseConfig> = {
	type: "object",
	required: ["fees", "wnear_id"],
	properties: {
		fees: {
			type: "object",
			required: ["fee", "fee_collector"],
			properties: {
				fee: {
					description: "1 pip == 1/100th of bip == 0.0001%",
					type: "integer",
					format: "uint32",
					minimum: 0,
				},
				fee_collector: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
			},
			additionalProperties: false,
		},
		roles: {
			default: { admins: {}, grantees: {}, super_admins: [] },
			type: "object",
			properties: {
				admins: {
					default: {},
					type: "object",
					additionalProperties: {
						type: "array",
						items: {
							description:
								'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
							type: "string",
						},
						uniqueItems: true,
					},
					required: [],
				},
				grantees: {
					default: {},
					type: "object",
					additionalProperties: {
						type: "array",
						items: {
							description:
								'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
							type: "string",
						},
						uniqueItems: true,
					},
					required: [],
				},
				super_admins: {
					default: [],
					type: "array",
					items: {
						description:
							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
						type: "string",
					},
					uniqueItems: true,
				},
			},
			additionalProperties: false,
		},
		wnear_id: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
	},
	additionalProperties: false,
};

export const DefusePayloadFor_DefuseIntentsSchema: JSONSchemaType<Types.DefusePayloadFor_DefuseIntents> =
	{
		type: "object",
		required: ["deadline", "nonce", "signer_id", "verifying_contract"],
		properties: {
			deadline: { type: "string" },
			intents: {
				description:
					"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
				type: "array",
				items: {
					oneOf: [
						{
							description: "See [`AddPublicKey`]",
							type: "object",
							required: ["intent", "public_key"],
							properties: {
								intent: { type: "string", enum: ["add_public_key"] },
								public_key: {
									examples: [
										"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
										"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
									],
									type: "string",
									description: "Encoding: base58",
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`RemovePublicKey`]",
							type: "object",
							required: ["intent", "public_key"],
							properties: {
								intent: { type: "string", enum: ["remove_public_key"] },
								public_key: {
									examples: [
										"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
										"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
									],
									type: "string",
									description: "Encoding: base58",
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`Transfer`]",
							type: "object",
							required: ["intent", "receiver_id", "tokens"],
							properties: {
								intent: { type: "string", enum: ["transfer"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description: "Message to pass to `mt_on_transfer`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								state_init: {
									description:
										"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
									oneOf: [
										{
											type: "object",
											required: ["code", "data", "version"],
											properties: {
												code: {
													oneOf: [
														{
															type: "object",
															required: ["hash"],
															properties: { hash: { type: "string" } },
															additionalProperties: false,
														},
														{
															type: "object",
															required: ["account_id"],
															properties: {
																account_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
															},
															additionalProperties: false,
														},
													],
												},
												data: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												version: { type: "string", enum: ["v1"] },
											},
											additionalProperties: false,
										},
										{ type: "null" },
									],
								},
								tokens: {
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`FtWithdraw`]",
							type: "object",
							required: ["amount", "intent", "receiver_id", "token"],
							properties: {
								amount: { type: "string" },
								intent: { type: "string", enum: ["ft_withdraw"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description:
										"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								storage_deposit: {
									description:
										"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
									type: "string",
									nullable: true,
								},
								token: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`NftWithdraw`]",
							type: "object",
							required: ["intent", "receiver_id", "token", "token_id"],
							properties: {
								intent: { type: "string", enum: ["nft_withdraw"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description:
										"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								storage_deposit: {
									description:
										"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
									type: "string",
									nullable: true,
								},
								token: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								token_id: { type: "string" },
							},
							additionalProperties: false,
						},
						{
							description: "See [`MtWithdraw`]",
							type: "object",
							required: [
								"amounts",
								"intent",
								"receiver_id",
								"token",
								"token_ids",
							],
							properties: {
								amounts: { type: "array", items: { type: "string" } },
								intent: { type: "string", enum: ["mt_withdraw"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description:
										"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								storage_deposit: {
									description:
										"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
									type: "string",
									nullable: true,
								},
								token: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								token_ids: { type: "array", items: { type: "string" } },
							},
							additionalProperties: false,
						},
						{
							description: "See [`NativeWithdraw`]",
							type: "object",
							required: ["amount", "intent", "receiver_id"],
							properties: {
								amount: { type: "string" },
								intent: { type: "string", enum: ["native_withdraw"] },
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`StorageDeposit`]",
							type: "object",
							required: [
								"amount",
								"contract_id",
								"deposit_for_account_id",
								"intent",
							],
							properties: {
								amount: { type: "string" },
								contract_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								deposit_for_account_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								intent: { type: "string", enum: ["storage_deposit"] },
							},
							additionalProperties: false,
						},
						{
							description: "See [`TokenDiff`]",
							type: "object",
							required: ["diff", "intent"],
							properties: {
								diff: {
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
								intent: { type: "string", enum: ["token_diff"] },
								memo: { type: "string", nullable: true },
								referral: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
									nullable: true,
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`SetAuthByPredecessorId`]",
							type: "object",
							required: ["enabled", "intent"],
							properties: {
								enabled: { type: "boolean" },
								intent: {
									type: "string",
									enum: ["set_auth_by_predecessor_id"],
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`AuthCall`]",
							type: "object",
							required: ["contract_id", "intent", "msg"],
							properties: {
								attached_deposit: {
									description:
										"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
									type: "string",
									nullable: true,
								},
								contract_id: {
									description:
										"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
									type: "string",
								},
								intent: { type: "string", enum: ["auth_call"] },
								min_gas: {
									description:
										"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description:
										"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
									type: "string",
								},
								state_init: {
									description:
										"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
									oneOf: [
										{
											type: "object",
											required: ["code", "data", "version"],
											properties: {
												code: {
													oneOf: [
														{
															type: "object",
															required: ["hash"],
															properties: { hash: { type: "string" } },
															additionalProperties: false,
														},
														{
															type: "object",
															required: ["account_id"],
															properties: {
																account_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
															},
															additionalProperties: false,
														},
													],
												},
												data: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												version: { type: "string", enum: ["v1"] },
											},
											additionalProperties: false,
										},
										{ type: "null" },
									],
								},
							},
							additionalProperties: false,
						},
						{
							description:
								"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
							type: "object",
							required: ["intent", "receiver_id", "tokens"],
							properties: {
								intent: { type: "string", enum: ["imt_mint"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description: "Message to pass to `mt_on_transfer`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description: "Receiver of the minted tokens",
									type: "string",
								},
								state_init: {
									description:
										"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
									oneOf: [
										{
											type: "object",
											required: ["code", "data", "version"],
											properties: {
												code: {
													oneOf: [
														{
															type: "object",
															required: ["hash"],
															properties: { hash: { type: "string" } },
															additionalProperties: false,
														},
														{
															type: "object",
															required: ["account_id"],
															properties: {
																account_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
															},
															additionalProperties: false,
														},
													],
												},
												data: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												version: { type: "string", enum: ["v1"] },
											},
											additionalProperties: false,
										},
										{ type: "null" },
									],
								},
								tokens: {
									description:
										"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
							},
							additionalProperties: false,
						},
						{
							description:
								"Burn a set of imt tokens, within the intents contract.",
							type: "object",
							required: ["intent", "minter_id", "tokens"],
							properties: {
								intent: { type: "string", enum: ["imt_burn"] },
								memo: { type: "string", nullable: true },
								minter_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								tokens: {
									description:
										"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
							},
							additionalProperties: false,
						},
					],
				},
				nullable: true,
			},
			nonce: {
				examples: ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],
				type: "string",
				description: "Encoding: base64",
			},
			signer_id: {
				description:
					'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
				type: "string",
			},
			verifying_contract: {
				description:
					'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
				type: "string",
			},
		},
		additionalProperties: false,
	};

export const Erc191PayloadSchema: JSONSchemaType<Types.Erc191Payload> = {
	description:
		"See [ERC-191](https://github.com/ethereum/ercs/blob/master/ERCS/erc-191.md)",
	type: "string",
};

export const FeesConfigSchema: JSONSchemaType<Types.FeesConfig> = {
	type: "object",
	required: ["fee", "fee_collector"],
	properties: {
		fee: {
			description: "1 pip == 1/100th of bip == 0.0001%",
			type: "integer",
			format: "uint32",
			minimum: 0,
		},
		fee_collector: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
	},
	additionalProperties: false,
};

export const FtWithdrawSchema: JSONSchemaType<Types.FtWithdraw> = {
	description:
		"Withdraw given FT tokens from the intents contract to a given external account id (external being outside of intents).",
	type: "object",
	required: ["amount", "receiver_id", "token"],
	properties: {
		amount: { type: "string" },
		memo: { type: "string", nullable: true },
		min_gas: {
			description:
				"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
			type: "string",
			nullable: true,
		},
		msg: {
			description:
				"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
			type: "string",
			nullable: true,
		},
		receiver_id: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
		storage_deposit: {
			description:
				"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
			type: "string",
			nullable: true,
		},
		token: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
	},
	additionalProperties: false,
};

export const GlobalContractIdSchema: JSONSchemaType<Types.GlobalContractId> = {
	oneOf: [
		{
			type: "object",
			required: ["hash"],
			properties: { hash: { type: "string" } },
			additionalProperties: false,
		},
		{
			type: "object",
			required: ["account_id"],
			properties: {
				account_id: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
			},
			additionalProperties: false,
		},
	],
};

export const IntentSchema: JSONSchemaType<Types.Intent> = {
	oneOf: [
		{
			description: "See [`AddPublicKey`]",
			type: "object",
			required: ["intent", "public_key"],
			properties: {
				intent: { type: "string", enum: ["add_public_key"] },
				public_key: {
					examples: [
						"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
						"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
					],
					type: "string",
					description: "Encoding: base58",
				},
			},
			additionalProperties: false,
		},
		{
			description: "See [`RemovePublicKey`]",
			type: "object",
			required: ["intent", "public_key"],
			properties: {
				intent: { type: "string", enum: ["remove_public_key"] },
				public_key: {
					examples: [
						"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
						"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
					],
					type: "string",
					description: "Encoding: base58",
				},
			},
			additionalProperties: false,
		},
		{
			description: "See [`Transfer`]",
			type: "object",
			required: ["intent", "receiver_id", "tokens"],
			properties: {
				intent: { type: "string", enum: ["transfer"] },
				memo: { type: "string", nullable: true },
				min_gas: {
					description:
						"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
					type: "string",
					nullable: true,
				},
				msg: {
					description: "Message to pass to `mt_on_transfer`",
					type: "string",
					nullable: true,
				},
				receiver_id: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
				state_init: {
					description:
						"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
					oneOf: [
						{
							type: "object",
							required: ["code", "data", "version"],
							properties: {
								code: {
									oneOf: [
										{
											type: "object",
											required: ["hash"],
											properties: { hash: { type: "string" } },
											additionalProperties: false,
										},
										{
											type: "object",
											required: ["account_id"],
											properties: {
												account_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
									],
								},
								data: {
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
								version: { type: "string", enum: ["v1"] },
							},
							additionalProperties: false,
						},
						{ type: "null" },
					],
				},
				tokens: {
					type: "object",
					additionalProperties: { type: "string" },
					required: [],
				},
			},
			additionalProperties: false,
		},
		{
			description: "See [`FtWithdraw`]",
			type: "object",
			required: ["amount", "intent", "receiver_id", "token"],
			properties: {
				amount: { type: "string" },
				intent: { type: "string", enum: ["ft_withdraw"] },
				memo: { type: "string", nullable: true },
				min_gas: {
					description:
						"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
					type: "string",
					nullable: true,
				},
				msg: {
					description:
						"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
					type: "string",
					nullable: true,
				},
				receiver_id: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
				storage_deposit: {
					description:
						"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
					type: "string",
					nullable: true,
				},
				token: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
			},
			additionalProperties: false,
		},
		{
			description: "See [`NftWithdraw`]",
			type: "object",
			required: ["intent", "receiver_id", "token", "token_id"],
			properties: {
				intent: { type: "string", enum: ["nft_withdraw"] },
				memo: { type: "string", nullable: true },
				min_gas: {
					description:
						"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
					type: "string",
					nullable: true,
				},
				msg: {
					description:
						"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
					type: "string",
					nullable: true,
				},
				receiver_id: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
				storage_deposit: {
					description:
						"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
					type: "string",
					nullable: true,
				},
				token: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
				token_id: { type: "string" },
			},
			additionalProperties: false,
		},
		{
			description: "See [`MtWithdraw`]",
			type: "object",
			required: ["amounts", "intent", "receiver_id", "token", "token_ids"],
			properties: {
				amounts: { type: "array", items: { type: "string" } },
				intent: { type: "string", enum: ["mt_withdraw"] },
				memo: { type: "string", nullable: true },
				min_gas: {
					description:
						"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
					type: "string",
					nullable: true,
				},
				msg: {
					description:
						"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
					type: "string",
					nullable: true,
				},
				receiver_id: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
				storage_deposit: {
					description:
						"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
					type: "string",
					nullable: true,
				},
				token: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
				token_ids: { type: "array", items: { type: "string" } },
			},
			additionalProperties: false,
		},
		{
			description: "See [`NativeWithdraw`]",
			type: "object",
			required: ["amount", "intent", "receiver_id"],
			properties: {
				amount: { type: "string" },
				intent: { type: "string", enum: ["native_withdraw"] },
				receiver_id: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
			},
			additionalProperties: false,
		},
		{
			description: "See [`StorageDeposit`]",
			type: "object",
			required: ["amount", "contract_id", "deposit_for_account_id", "intent"],
			properties: {
				amount: { type: "string" },
				contract_id: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
				deposit_for_account_id: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
				intent: { type: "string", enum: ["storage_deposit"] },
			},
			additionalProperties: false,
		},
		{
			description: "See [`TokenDiff`]",
			type: "object",
			required: ["diff", "intent"],
			properties: {
				diff: {
					type: "object",
					additionalProperties: { type: "string" },
					required: [],
				},
				intent: { type: "string", enum: ["token_diff"] },
				memo: { type: "string", nullable: true },
				referral: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
					nullable: true,
				},
			},
			additionalProperties: false,
		},
		{
			description: "See [`SetAuthByPredecessorId`]",
			type: "object",
			required: ["enabled", "intent"],
			properties: {
				enabled: { type: "boolean" },
				intent: { type: "string", enum: ["set_auth_by_predecessor_id"] },
			},
			additionalProperties: false,
		},
		{
			description: "See [`AuthCall`]",
			type: "object",
			required: ["contract_id", "intent", "msg"],
			properties: {
				attached_deposit: {
					description:
						"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
					type: "string",
					nullable: true,
				},
				contract_id: {
					description:
						"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
					type: "string",
				},
				intent: { type: "string", enum: ["auth_call"] },
				min_gas: {
					description:
						"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
					type: "string",
					nullable: true,
				},
				msg: {
					description:
						"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
					type: "string",
				},
				state_init: {
					description:
						"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
					oneOf: [
						{
							type: "object",
							required: ["code", "data", "version"],
							properties: {
								code: {
									oneOf: [
										{
											type: "object",
											required: ["hash"],
											properties: { hash: { type: "string" } },
											additionalProperties: false,
										},
										{
											type: "object",
											required: ["account_id"],
											properties: {
												account_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
									],
								},
								data: {
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
								version: { type: "string", enum: ["v1"] },
							},
							additionalProperties: false,
						},
						{ type: "null" },
					],
				},
			},
			additionalProperties: false,
		},
		{
			description:
				"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
			type: "object",
			required: ["intent", "receiver_id", "tokens"],
			properties: {
				intent: { type: "string", enum: ["imt_mint"] },
				memo: { type: "string", nullable: true },
				min_gas: {
					description:
						"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
					type: "string",
					nullable: true,
				},
				msg: {
					description: "Message to pass to `mt_on_transfer`",
					type: "string",
					nullable: true,
				},
				receiver_id: {
					description: "Receiver of the minted tokens",
					type: "string",
				},
				state_init: {
					description:
						"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
					oneOf: [
						{
							type: "object",
							required: ["code", "data", "version"],
							properties: {
								code: {
									oneOf: [
										{
											type: "object",
											required: ["hash"],
											properties: { hash: { type: "string" } },
											additionalProperties: false,
										},
										{
											type: "object",
											required: ["account_id"],
											properties: {
												account_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
									],
								},
								data: {
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
								version: { type: "string", enum: ["v1"] },
							},
							additionalProperties: false,
						},
						{ type: "null" },
					],
				},
				tokens: {
					description:
						"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
					type: "object",
					additionalProperties: { type: "string" },
					required: [],
				},
			},
			additionalProperties: false,
		},
		{
			description: "Burn a set of imt tokens, within the intents contract.",
			type: "object",
			required: ["intent", "minter_id", "tokens"],
			properties: {
				intent: { type: "string", enum: ["imt_burn"] },
				memo: { type: "string", nullable: true },
				minter_id: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
				tokens: {
					description:
						"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
					type: "object",
					additionalProperties: { type: "string" },
					required: [],
				},
			},
			additionalProperties: false,
		},
	],
};

export const IntentEventFor_AccountEventFor_NonceEventSchema: JSONSchemaType<Types.IntentEventFor_AccountEventFor_NonceEvent> =
	{
		type: "object",
		required: ["account_id", "intent_hash", "nonce"],
		properties: {
			account_id: {
				description:
					'Account identifier. This is the human readable UTF-8 string which is used internally to index accounts on the network and their respective state.\n\nThis is the "referenced" version of the account ID. It is to [`AccountId`] what [`str`] is to [`String`], and works quite similarly to [`Path`]. Like with [`str`] and [`Path`], you can\'t have a value of type `AccountIdRef`, but you can have a reference like `&AccountIdRef` or `&mut AccountIdRef`.\n\nThis type supports zero-copy deserialization offered by [`serde`](https://docs.rs/serde/), but cannot do the same for [`borsh`](https://docs.rs/borsh/) since the latter does not support zero-copy.\n\n# Examples ``` use near_account_id::{AccountId, AccountIdRef}; use std::convert::{TryFrom, TryInto};\n\n// Construction let alice = AccountIdRef::new("alice.near").unwrap(); assert!(AccountIdRef::new("invalid.").is_err()); ```\n\n[`FromStr`]: std::str::FromStr [`Path`]: std::path::Path',
				type: "string",
			},
			intent_hash: { type: "string", description: "Encoding: base58" },
			nonce: { type: "string", description: "Encoding: base64" },
		},
		additionalProperties: false,
	};

export const InvariantViolatedSchema: JSONSchemaType<Types.InvariantViolated> =
	{
		oneOf: [
			{
				type: "object",
				required: ["error", "unmatched_deltas"],
				properties: {
					error: { type: "string", enum: ["unmatched_deltas"] },
					unmatched_deltas: {
						type: "object",
						additionalProperties: { type: "string" },
						required: [],
					},
				},
				additionalProperties: false,
			},
			{
				type: "object",
				required: ["error"],
				properties: { error: { type: "string", enum: ["overflow"] } },
				additionalProperties: false,
			},
		],
	};

export const MtWithdrawSchema: JSONSchemaType<Types.MtWithdraw> = {
	description:
		"Withdraw given MT tokens (i.e. [NEP-245](https://github.com/near/NEPs/blob/master/neps/nep-0245.md)) from the intents contract to a given to an external account id (external being outside of intents).\n\nIf `msg` is given, `mt_batch_transfer_call()` will be used to transfer to the `receiver_id`. Otherwise, `mt_batch_transfer()` will be used.",
	type: "object",
	required: ["amounts", "receiver_id", "token", "token_ids"],
	properties: {
		amounts: { type: "array", items: { type: "string" } },
		memo: { type: "string", nullable: true },
		min_gas: {
			description:
				"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
			type: "string",
			nullable: true,
		},
		msg: {
			description:
				"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
			type: "string",
			nullable: true,
		},
		receiver_id: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
		storage_deposit: {
			description:
				"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
			type: "string",
			nullable: true,
		},
		token: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
		token_ids: { type: "array", items: { type: "string" } },
	},
	additionalProperties: false,
};

// MultiPayloadSchema is type-checked against the unparsed type, then exported as the Parsed type.
// This is correct because parseJson transforms string payloads into objects at runtime.
const _MultiPayloadSchemaCheck: JSONSchemaType<Types.MultiPayload> = {
	description:
		"Assuming wallets want to interact with Intents protocol, besides preparing the data in a certain form, they have to have the capability to sign raw messages (off-chain signatures) using an algorithm we understand. This enum solves that problem.\n\nFor example, because we support ERC-191 and know how to verify messages with that standard, we can allow wallets, like Metamask, sign messages to perform intents without having to support new cryptographic primitives and signing standards.",
	oneOf: [
		{
			description:
				"NEP-413: The standard for message signing in Near Protocol. For more details, refer to [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md).",
			type: "object",
			required: ["payload", "public_key", "signature", "standard"],
			properties: {
				payload: {
					description:
						"See [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)",
					type: "object",
					required: ["message", "nonce", "recipient"],
					properties: {
						callbackUrl: { type: "string", nullable: true },
						message: {
							type: "string",
							parseJson: {
								type: "object",
								required: ["deadline", "signer_id"],
								properties: {
									deadline: { type: "string" },
									signer_id: {
										description:
											'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
										type: "string",
									},
									intents: {
										description:
											"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
										type: "array",
										items: {
											oneOf: [
												{
													description: "See [`AddPublicKey`]",
													type: "object",
													required: ["intent", "public_key"],
													properties: {
														intent: {
															type: "string",
															enum: ["add_public_key"],
														},
														public_key: {
															examples: [
																"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
																"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
															],
															type: "string",
															description: "Encoding: base58",
														},
													},
													additionalProperties: false,
												},
												{
													description: "See [`RemovePublicKey`]",
													type: "object",
													required: ["intent", "public_key"],
													properties: {
														intent: {
															type: "string",
															enum: ["remove_public_key"],
														},
														public_key: {
															examples: [
																"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
																"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
															],
															type: "string",
															description: "Encoding: base58",
														},
													},
													additionalProperties: false,
												},
												{
													description: "See [`Transfer`]",
													type: "object",
													required: ["intent", "receiver_id", "tokens"],
													properties: {
														intent: { type: "string", enum: ["transfer"] },
														memo: { type: "string", nullable: true },
														min_gas: {
															description:
																"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
															type: "string",
															nullable: true,
														},
														msg: {
															description:
																"Message to pass to `mt_on_transfer`",
															type: "string",
															nullable: true,
														},
														receiver_id: {
															description:
																'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
															type: "string",
														},
														state_init: {
															description:
																"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
															oneOf: [
																{
																	type: "object",
																	required: ["code", "data", "version"],
																	properties: {
																		code: {
																			oneOf: [
																				{
																					type: "object",
																					required: ["hash"],
																					properties: {
																						hash: { type: "string" },
																					},
																					additionalProperties: false,
																				},
																				{
																					type: "object",
																					required: ["account_id"],
																					properties: {
																						account_id: {
																							description:
																								'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																							type: "string",
																						},
																					},
																					additionalProperties: false,
																				},
																			],
																		},
																		data: {
																			type: "object",
																			additionalProperties: { type: "string" },
																			required: [],
																		},
																		version: { type: "string", enum: ["v1"] },
																	},
																	additionalProperties: false,
																},
																{ type: "null" },
															],
														},
														tokens: {
															type: "object",
															additionalProperties: { type: "string" },
															required: [],
														},
													},
													additionalProperties: false,
												},
												{
													description: "See [`FtWithdraw`]",
													type: "object",
													required: [
														"amount",
														"intent",
														"receiver_id",
														"token",
													],
													properties: {
														amount: { type: "string" },
														intent: { type: "string", enum: ["ft_withdraw"] },
														memo: { type: "string", nullable: true },
														min_gas: {
															description:
																"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
															type: "string",
															nullable: true,
														},
														msg: {
															description:
																"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
															type: "string",
															nullable: true,
														},
														receiver_id: {
															description:
																'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
															type: "string",
														},
														storage_deposit: {
															description:
																"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
															type: "string",
															nullable: true,
														},
														token: {
															description:
																'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
															type: "string",
														},
													},
													additionalProperties: false,
												},
												{
													description: "See [`NftWithdraw`]",
													type: "object",
													required: [
														"intent",
														"receiver_id",
														"token",
														"token_id",
													],
													properties: {
														intent: { type: "string", enum: ["nft_withdraw"] },
														memo: { type: "string", nullable: true },
														min_gas: {
															description:
																"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
															type: "string",
															nullable: true,
														},
														msg: {
															description:
																"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
															type: "string",
															nullable: true,
														},
														receiver_id: {
															description:
																'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
															type: "string",
														},
														storage_deposit: {
															description:
																"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
															type: "string",
															nullable: true,
														},
														token: {
															description:
																'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
															type: "string",
														},
														token_id: { type: "string" },
													},
													additionalProperties: false,
												},
												{
													description: "See [`MtWithdraw`]",
													type: "object",
													required: [
														"amounts",
														"intent",
														"receiver_id",
														"token",
														"token_ids",
													],
													properties: {
														amounts: {
															type: "array",
															items: { type: "string" },
														},
														intent: { type: "string", enum: ["mt_withdraw"] },
														memo: { type: "string", nullable: true },
														min_gas: {
															description:
																"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
															type: "string",
															nullable: true,
														},
														msg: {
															description:
																"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
															type: "string",
															nullable: true,
														},
														receiver_id: {
															description:
																'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
															type: "string",
														},
														storage_deposit: {
															description:
																"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
															type: "string",
															nullable: true,
														},
														token: {
															description:
																'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
															type: "string",
														},
														token_ids: {
															type: "array",
															items: { type: "string" },
														},
													},
													additionalProperties: false,
												},
												{
													description: "See [`NativeWithdraw`]",
													type: "object",
													required: ["amount", "intent", "receiver_id"],
													properties: {
														amount: { type: "string" },
														intent: {
															type: "string",
															enum: ["native_withdraw"],
														},
														receiver_id: {
															description:
																'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
															type: "string",
														},
													},
													additionalProperties: false,
												},
												{
													description: "See [`StorageDeposit`]",
													type: "object",
													required: [
														"amount",
														"contract_id",
														"deposit_for_account_id",
														"intent",
													],
													properties: {
														amount: { type: "string" },
														contract_id: {
															description:
																'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
															type: "string",
														},
														deposit_for_account_id: {
															description:
																'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
															type: "string",
														},
														intent: {
															type: "string",
															enum: ["storage_deposit"],
														},
													},
													additionalProperties: false,
												},
												{
													description: "See [`TokenDiff`]",
													type: "object",
													required: ["diff", "intent"],
													properties: {
														diff: {
															type: "object",
															additionalProperties: { type: "string" },
															required: [],
														},
														intent: { type: "string", enum: ["token_diff"] },
														memo: { type: "string", nullable: true },
														referral: {
															description:
																'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
															type: "string",
															nullable: true,
														},
													},
													additionalProperties: false,
												},
												{
													description: "See [`SetAuthByPredecessorId`]",
													type: "object",
													required: ["enabled", "intent"],
													properties: {
														enabled: { type: "boolean" },
														intent: {
															type: "string",
															enum: ["set_auth_by_predecessor_id"],
														},
													},
													additionalProperties: false,
												},
												{
													description: "See [`AuthCall`]",
													type: "object",
													required: ["contract_id", "intent", "msg"],
													properties: {
														attached_deposit: {
															description:
																"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
															type: "string",
															nullable: true,
														},
														contract_id: {
															description:
																"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
															type: "string",
														},
														intent: { type: "string", enum: ["auth_call"] },
														min_gas: {
															description:
																"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
															type: "string",
															nullable: true,
														},
														msg: {
															description:
																"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
															type: "string",
														},
														state_init: {
															description:
																"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
															oneOf: [
																{
																	type: "object",
																	required: ["code", "data", "version"],
																	properties: {
																		code: {
																			oneOf: [
																				{
																					type: "object",
																					required: ["hash"],
																					properties: {
																						hash: { type: "string" },
																					},
																					additionalProperties: false,
																				},
																				{
																					type: "object",
																					required: ["account_id"],
																					properties: {
																						account_id: {
																							description:
																								'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																							type: "string",
																						},
																					},
																					additionalProperties: false,
																				},
																			],
																		},
																		data: {
																			type: "object",
																			additionalProperties: { type: "string" },
																			required: [],
																		},
																		version: { type: "string", enum: ["v1"] },
																	},
																	additionalProperties: false,
																},
																{ type: "null" },
															],
														},
													},
													additionalProperties: false,
												},
												{
													description:
														"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
													type: "object",
													required: ["intent", "receiver_id", "tokens"],
													properties: {
														intent: { type: "string", enum: ["imt_mint"] },
														memo: { type: "string", nullable: true },
														min_gas: {
															description:
																"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
															type: "string",
															nullable: true,
														},
														msg: {
															description:
																"Message to pass to `mt_on_transfer`",
															type: "string",
															nullable: true,
														},
														receiver_id: {
															description: "Receiver of the minted tokens",
															type: "string",
														},
														state_init: {
															description:
																"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
															oneOf: [
																{
																	type: "object",
																	required: ["code", "data", "version"],
																	properties: {
																		code: {
																			oneOf: [
																				{
																					type: "object",
																					required: ["hash"],
																					properties: {
																						hash: { type: "string" },
																					},
																					additionalProperties: false,
																				},
																				{
																					type: "object",
																					required: ["account_id"],
																					properties: {
																						account_id: {
																							description:
																								'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																							type: "string",
																						},
																					},
																					additionalProperties: false,
																				},
																			],
																		},
																		data: {
																			type: "object",
																			additionalProperties: { type: "string" },
																			required: [],
																		},
																		version: { type: "string", enum: ["v1"] },
																	},
																	additionalProperties: false,
																},
																{ type: "null" },
															],
														},
														tokens: {
															description:
																"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
															type: "object",
															additionalProperties: { type: "string" },
															required: [],
														},
													},
													additionalProperties: false,
												},
												{
													description:
														"Burn a set of imt tokens, within the intents contract.",
													type: "object",
													required: ["intent", "minter_id", "tokens"],
													properties: {
														intent: { type: "string", enum: ["imt_burn"] },
														memo: { type: "string", nullable: true },
														minter_id: {
															description:
																'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
															type: "string",
														},
														tokens: {
															description:
																"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
															type: "object",
															additionalProperties: { type: "string" },
															required: [],
														},
													},
													additionalProperties: false,
												},
											],
										},
										nullable: true,
									},
								},
								additionalProperties: false,
							},
						},
						nonce: { type: "string", description: "Encoding: base64" },
						recipient: { type: "string" },
					},
					additionalProperties: false,
				},
				public_key: {
					type: "string",
					pattern: "^ed25519:",
					description: "Encoding: base58",
				},
				signature: {
					type: "string",
					pattern: "^ed25519:",
					description: "Encoding: base58",
				},
				standard: { type: "string", enum: ["nep413"] },
			},
			additionalProperties: false,
		},
		{
			description:
				"ERC-191: The standard for message signing in Ethereum, commonly used with `personal_sign()`. For more details, refer to [EIP-191](https://eips.ethereum.org/EIPS/eip-191).",
			type: "object",
			required: ["payload", "signature", "standard"],
			properties: {
				payload: {
					description:
						"See [ERC-191](https://github.com/ethereum/ercs/blob/master/ERCS/erc-191.md)",
					type: "string",
					parseJson: {
						type: "object",
						required: ["deadline", "nonce", "signer_id", "verifying_contract"],
						properties: {
							deadline: { type: "string" },
							intents: {
								description:
									"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
								type: "array",
								items: {
									oneOf: [
										{
											description: "See [`AddPublicKey`]",
											type: "object",
											required: ["intent", "public_key"],
											properties: {
												intent: { type: "string", enum: ["add_public_key"] },
												public_key: {
													examples: [
														"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
														"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
													],
													type: "string",
													description: "Encoding: base58",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`RemovePublicKey`]",
											type: "object",
											required: ["intent", "public_key"],
											properties: {
												intent: { type: "string", enum: ["remove_public_key"] },
												public_key: {
													examples: [
														"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
														"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
													],
													type: "string",
													description: "Encoding: base58",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`Transfer`]",
											type: "object",
											required: ["intent", "receiver_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["transfer"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description: "Message to pass to `mt_on_transfer`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
												tokens: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`FtWithdraw`]",
											type: "object",
											required: ["amount", "intent", "receiver_id", "token"],
											properties: {
												amount: { type: "string" },
												intent: { type: "string", enum: ["ft_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`NftWithdraw`]",
											type: "object",
											required: ["intent", "receiver_id", "token", "token_id"],
											properties: {
												intent: { type: "string", enum: ["nft_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												token_id: { type: "string" },
											},
											additionalProperties: false,
										},
										{
											description: "See [`MtWithdraw`]",
											type: "object",
											required: [
												"amounts",
												"intent",
												"receiver_id",
												"token",
												"token_ids",
											],
											properties: {
												amounts: { type: "array", items: { type: "string" } },
												intent: { type: "string", enum: ["mt_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												token_ids: { type: "array", items: { type: "string" } },
											},
											additionalProperties: false,
										},
										{
											description: "See [`NativeWithdraw`]",
											type: "object",
											required: ["amount", "intent", "receiver_id"],
											properties: {
												amount: { type: "string" },
												intent: { type: "string", enum: ["native_withdraw"] },
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`StorageDeposit`]",
											type: "object",
											required: [
												"amount",
												"contract_id",
												"deposit_for_account_id",
												"intent",
											],
											properties: {
												amount: { type: "string" },
												contract_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												deposit_for_account_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												intent: { type: "string", enum: ["storage_deposit"] },
											},
											additionalProperties: false,
										},
										{
											description: "See [`TokenDiff`]",
											type: "object",
											required: ["diff", "intent"],
											properties: {
												diff: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												intent: { type: "string", enum: ["token_diff"] },
												memo: { type: "string", nullable: true },
												referral: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
													nullable: true,
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`SetAuthByPredecessorId`]",
											type: "object",
											required: ["enabled", "intent"],
											properties: {
												enabled: { type: "boolean" },
												intent: {
													type: "string",
													enum: ["set_auth_by_predecessor_id"],
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`AuthCall`]",
											type: "object",
											required: ["contract_id", "intent", "msg"],
											properties: {
												attached_deposit: {
													description:
														"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
													type: "string",
													nullable: true,
												},
												contract_id: {
													description:
														"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
													type: "string",
												},
												intent: { type: "string", enum: ["auth_call"] },
												min_gas: {
													description:
														"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
											},
											additionalProperties: false,
										},
										{
											description:
												"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
											type: "object",
											required: ["intent", "receiver_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["imt_mint"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description: "Message to pass to `mt_on_transfer`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description: "Receiver of the minted tokens",
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
												tokens: {
													description:
														"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
										{
											description:
												"Burn a set of imt tokens, within the intents contract.",
											type: "object",
											required: ["intent", "minter_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["imt_burn"] },
												memo: { type: "string", nullable: true },
												minter_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												tokens: {
													description:
														"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
									],
								},
								nullable: true,
							},
							nonce: {
								examples: ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],
								type: "string",
								description: "Encoding: base64",
							},
							signer_id: {
								description:
									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
								type: "string",
							},
							verifying_contract: {
								description:
									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
								type: "string",
							},
						},
						additionalProperties: false,
					},
				},
				signature: {
					description:
						"There is no public key member because the public key can be recovered via `ecrecover()` knowing the data and the signature. Encoding: base58",
					type: "string",
					pattern: "^secp256k1:",
				},
				standard: { type: "string", enum: ["erc191"] },
			},
			additionalProperties: false,
		},
		{
			description:
				"TIP-191: The standard for message signing in Tron. For more details, refer to [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md).",
			type: "object",
			required: ["payload", "signature", "standard"],
			properties: {
				payload: {
					description:
						"See [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md)",
					type: "string",
					parseJson: {
						type: "object",
						required: ["deadline", "nonce", "signer_id", "verifying_contract"],
						properties: {
							deadline: { type: "string" },
							intents: {
								description:
									"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
								type: "array",
								items: {
									oneOf: [
										{
											description: "See [`AddPublicKey`]",
											type: "object",
											required: ["intent", "public_key"],
											properties: {
												intent: { type: "string", enum: ["add_public_key"] },
												public_key: {
													examples: [
														"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
														"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
													],
													type: "string",
													description: "Encoding: base58",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`RemovePublicKey`]",
											type: "object",
											required: ["intent", "public_key"],
											properties: {
												intent: { type: "string", enum: ["remove_public_key"] },
												public_key: {
													examples: [
														"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
														"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
													],
													type: "string",
													description: "Encoding: base58",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`Transfer`]",
											type: "object",
											required: ["intent", "receiver_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["transfer"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description: "Message to pass to `mt_on_transfer`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
												tokens: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`FtWithdraw`]",
											type: "object",
											required: ["amount", "intent", "receiver_id", "token"],
											properties: {
												amount: { type: "string" },
												intent: { type: "string", enum: ["ft_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`NftWithdraw`]",
											type: "object",
											required: ["intent", "receiver_id", "token", "token_id"],
											properties: {
												intent: { type: "string", enum: ["nft_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												token_id: { type: "string" },
											},
											additionalProperties: false,
										},
										{
											description: "See [`MtWithdraw`]",
											type: "object",
											required: [
												"amounts",
												"intent",
												"receiver_id",
												"token",
												"token_ids",
											],
											properties: {
												amounts: { type: "array", items: { type: "string" } },
												intent: { type: "string", enum: ["mt_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												token_ids: { type: "array", items: { type: "string" } },
											},
											additionalProperties: false,
										},
										{
											description: "See [`NativeWithdraw`]",
											type: "object",
											required: ["amount", "intent", "receiver_id"],
											properties: {
												amount: { type: "string" },
												intent: { type: "string", enum: ["native_withdraw"] },
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`StorageDeposit`]",
											type: "object",
											required: [
												"amount",
												"contract_id",
												"deposit_for_account_id",
												"intent",
											],
											properties: {
												amount: { type: "string" },
												contract_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												deposit_for_account_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												intent: { type: "string", enum: ["storage_deposit"] },
											},
											additionalProperties: false,
										},
										{
											description: "See [`TokenDiff`]",
											type: "object",
											required: ["diff", "intent"],
											properties: {
												diff: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												intent: { type: "string", enum: ["token_diff"] },
												memo: { type: "string", nullable: true },
												referral: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
													nullable: true,
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`SetAuthByPredecessorId`]",
											type: "object",
											required: ["enabled", "intent"],
											properties: {
												enabled: { type: "boolean" },
												intent: {
													type: "string",
													enum: ["set_auth_by_predecessor_id"],
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`AuthCall`]",
											type: "object",
											required: ["contract_id", "intent", "msg"],
											properties: {
												attached_deposit: {
													description:
														"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
													type: "string",
													nullable: true,
												},
												contract_id: {
													description:
														"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
													type: "string",
												},
												intent: { type: "string", enum: ["auth_call"] },
												min_gas: {
													description:
														"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
											},
											additionalProperties: false,
										},
										{
											description:
												"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
											type: "object",
											required: ["intent", "receiver_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["imt_mint"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description: "Message to pass to `mt_on_transfer`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description: "Receiver of the minted tokens",
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
												tokens: {
													description:
														"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
										{
											description:
												"Burn a set of imt tokens, within the intents contract.",
											type: "object",
											required: ["intent", "minter_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["imt_burn"] },
												memo: { type: "string", nullable: true },
												minter_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												tokens: {
													description:
														"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
									],
								},
								nullable: true,
							},
							nonce: {
								examples: ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],
								type: "string",
								description: "Encoding: base64",
							},
							signer_id: {
								description:
									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
								type: "string",
							},
							verifying_contract: {
								description:
									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
								type: "string",
							},
						},
						additionalProperties: false,
					},
				},
				signature: {
					description:
						"There is no public key member because the public key can be recovered via `ecrecover()` knowing the data and the signature. Encoding: base58",
					type: "string",
					pattern: "^secp256k1:",
				},
				standard: { type: "string", enum: ["tip191"] },
			},
			additionalProperties: false,
		},
		{
			description:
				"Raw Ed25519: The standard used by Solana Phantom wallets for message signing. For more details, refer to [Phantom Wallet's documentation](https://docs.phantom.com/solana/signing-a-message).",
			type: "object",
			required: ["payload", "public_key", "signature", "standard"],
			properties: {
				payload: {
					type: "string",
					parseJson: {
						type: "object",
						required: ["deadline", "nonce", "signer_id", "verifying_contract"],
						properties: {
							deadline: { type: "string" },
							intents: {
								description:
									"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
								type: "array",
								items: {
									oneOf: [
										{
											description: "See [`AddPublicKey`]",
											type: "object",
											required: ["intent", "public_key"],
											properties: {
												intent: { type: "string", enum: ["add_public_key"] },
												public_key: {
													examples: [
														"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
														"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
													],
													type: "string",
													description: "Encoding: base58",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`RemovePublicKey`]",
											type: "object",
											required: ["intent", "public_key"],
											properties: {
												intent: { type: "string", enum: ["remove_public_key"] },
												public_key: {
													examples: [
														"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
														"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
													],
													type: "string",
													description: "Encoding: base58",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`Transfer`]",
											type: "object",
											required: ["intent", "receiver_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["transfer"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description: "Message to pass to `mt_on_transfer`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
												tokens: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`FtWithdraw`]",
											type: "object",
											required: ["amount", "intent", "receiver_id", "token"],
											properties: {
												amount: { type: "string" },
												intent: { type: "string", enum: ["ft_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`NftWithdraw`]",
											type: "object",
											required: ["intent", "receiver_id", "token", "token_id"],
											properties: {
												intent: { type: "string", enum: ["nft_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												token_id: { type: "string" },
											},
											additionalProperties: false,
										},
										{
											description: "See [`MtWithdraw`]",
											type: "object",
											required: [
												"amounts",
												"intent",
												"receiver_id",
												"token",
												"token_ids",
											],
											properties: {
												amounts: { type: "array", items: { type: "string" } },
												intent: { type: "string", enum: ["mt_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												token_ids: { type: "array", items: { type: "string" } },
											},
											additionalProperties: false,
										},
										{
											description: "See [`NativeWithdraw`]",
											type: "object",
											required: ["amount", "intent", "receiver_id"],
											properties: {
												amount: { type: "string" },
												intent: { type: "string", enum: ["native_withdraw"] },
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`StorageDeposit`]",
											type: "object",
											required: [
												"amount",
												"contract_id",
												"deposit_for_account_id",
												"intent",
											],
											properties: {
												amount: { type: "string" },
												contract_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												deposit_for_account_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												intent: { type: "string", enum: ["storage_deposit"] },
											},
											additionalProperties: false,
										},
										{
											description: "See [`TokenDiff`]",
											type: "object",
											required: ["diff", "intent"],
											properties: {
												diff: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												intent: { type: "string", enum: ["token_diff"] },
												memo: { type: "string", nullable: true },
												referral: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
													nullable: true,
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`SetAuthByPredecessorId`]",
											type: "object",
											required: ["enabled", "intent"],
											properties: {
												enabled: { type: "boolean" },
												intent: {
													type: "string",
													enum: ["set_auth_by_predecessor_id"],
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`AuthCall`]",
											type: "object",
											required: ["contract_id", "intent", "msg"],
											properties: {
												attached_deposit: {
													description:
														"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
													type: "string",
													nullable: true,
												},
												contract_id: {
													description:
														"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
													type: "string",
												},
												intent: { type: "string", enum: ["auth_call"] },
												min_gas: {
													description:
														"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
											},
											additionalProperties: false,
										},
										{
											description:
												"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
											type: "object",
											required: ["intent", "receiver_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["imt_mint"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description: "Message to pass to `mt_on_transfer`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description: "Receiver of the minted tokens",
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
												tokens: {
													description:
														"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
										{
											description:
												"Burn a set of imt tokens, within the intents contract.",
											type: "object",
											required: ["intent", "minter_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["imt_burn"] },
												memo: { type: "string", nullable: true },
												minter_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												tokens: {
													description:
														"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
									],
								},
								nullable: true,
							},
							nonce: {
								examples: ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],
								type: "string",
								description: "Encoding: base64",
							},
							signer_id: {
								description:
									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
								type: "string",
							},
							verifying_contract: {
								description:
									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
								type: "string",
							},
						},
						additionalProperties: false,
					},
				},
				public_key: {
					type: "string",
					pattern: "^ed25519:",
					description: "Encoding: base58",
				},
				signature: {
					type: "string",
					pattern: "^ed25519:",
					description: "Encoding: base58",
				},
				standard: { type: "string", enum: ["raw_ed25519"] },
			},
			additionalProperties: false,
		},
		{
			type: "object",
			required: [
				"authenticator_data",
				"client_data_json",
				"payload",
				"standard",
				"public_key",
				"signature",
			],
			properties: {
				authenticator_data: {
					description:
						"Base64Url-encoded [authenticatorData](https://w3c.github.io/webauthn/#authenticator-data). Encoding: base64",
					type: "string",
				},
				client_data_json: {
					description:
						"Serialized [clientDataJSON](https://w3c.github.io/webauthn/#dom-authenticatorresponse-clientdatajson)",
					type: "string",
				},
				payload: {
					type: "string",
					parseJson: {
						type: "object",
						required: ["deadline", "nonce", "signer_id", "verifying_contract"],
						properties: {
							deadline: { type: "string" },
							intents: {
								description:
									"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
								type: "array",
								items: {
									oneOf: [
										{
											description: "See [`AddPublicKey`]",
											type: "object",
											required: ["intent", "public_key"],
											properties: {
												intent: { type: "string", enum: ["add_public_key"] },
												public_key: {
													examples: [
														"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
														"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
													],
													type: "string",
													description: "Encoding: base58",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`RemovePublicKey`]",
											type: "object",
											required: ["intent", "public_key"],
											properties: {
												intent: { type: "string", enum: ["remove_public_key"] },
												public_key: {
													examples: [
														"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
														"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
													],
													type: "string",
													description: "Encoding: base58",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`Transfer`]",
											type: "object",
											required: ["intent", "receiver_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["transfer"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description: "Message to pass to `mt_on_transfer`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
												tokens: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`FtWithdraw`]",
											type: "object",
											required: ["amount", "intent", "receiver_id", "token"],
											properties: {
												amount: { type: "string" },
												intent: { type: "string", enum: ["ft_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`NftWithdraw`]",
											type: "object",
											required: ["intent", "receiver_id", "token", "token_id"],
											properties: {
												intent: { type: "string", enum: ["nft_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												token_id: { type: "string" },
											},
											additionalProperties: false,
										},
										{
											description: "See [`MtWithdraw`]",
											type: "object",
											required: [
												"amounts",
												"intent",
												"receiver_id",
												"token",
												"token_ids",
											],
											properties: {
												amounts: { type: "array", items: { type: "string" } },
												intent: { type: "string", enum: ["mt_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												token_ids: { type: "array", items: { type: "string" } },
											},
											additionalProperties: false,
										},
										{
											description: "See [`NativeWithdraw`]",
											type: "object",
											required: ["amount", "intent", "receiver_id"],
											properties: {
												amount: { type: "string" },
												intent: { type: "string", enum: ["native_withdraw"] },
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`StorageDeposit`]",
											type: "object",
											required: [
												"amount",
												"contract_id",
												"deposit_for_account_id",
												"intent",
											],
											properties: {
												amount: { type: "string" },
												contract_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												deposit_for_account_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												intent: { type: "string", enum: ["storage_deposit"] },
											},
											additionalProperties: false,
										},
										{
											description: "See [`TokenDiff`]",
											type: "object",
											required: ["diff", "intent"],
											properties: {
												diff: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												intent: { type: "string", enum: ["token_diff"] },
												memo: { type: "string", nullable: true },
												referral: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
													nullable: true,
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`SetAuthByPredecessorId`]",
											type: "object",
											required: ["enabled", "intent"],
											properties: {
												enabled: { type: "boolean" },
												intent: {
													type: "string",
													enum: ["set_auth_by_predecessor_id"],
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`AuthCall`]",
											type: "object",
											required: ["contract_id", "intent", "msg"],
											properties: {
												attached_deposit: {
													description:
														"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
													type: "string",
													nullable: true,
												},
												contract_id: {
													description:
														"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
													type: "string",
												},
												intent: { type: "string", enum: ["auth_call"] },
												min_gas: {
													description:
														"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
											},
											additionalProperties: false,
										},
										{
											description:
												"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
											type: "object",
											required: ["intent", "receiver_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["imt_mint"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description: "Message to pass to `mt_on_transfer`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description: "Receiver of the minted tokens",
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
												tokens: {
													description:
														"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
										{
											description:
												"Burn a set of imt tokens, within the intents contract.",
											type: "object",
											required: ["intent", "minter_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["imt_burn"] },
												memo: { type: "string", nullable: true },
												minter_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												tokens: {
													description:
														"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
									],
								},
								nullable: true,
							},
							nonce: {
								examples: ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],
								type: "string",
								description: "Encoding: base64",
							},
							signer_id: {
								description:
									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
								type: "string",
							},
							verifying_contract: {
								description:
									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
								type: "string",
							},
						},
						additionalProperties: false,
					},
				},
				standard: { type: "string", enum: ["webauthn"] },
				public_key: {
					type: "string",
					pattern: "^p256:",
					description: "Encoding: base58",
				},
				signature: {
					type: "string",
					pattern: "^p256:",
					description: "Encoding: base58",
				},
			},
			description:
				"[COSE ES256 (-7) algorithm](https://www.iana.org/assignments/cose/cose.xhtml#algorithms): NIST P-256 curve (a.k.a secp256r1) over SHA-256",
			additionalProperties: false,
		},
		{
			type: "object",
			required: [
				"authenticator_data",
				"client_data_json",
				"payload",
				"standard",
				"public_key",
				"signature",
			],
			properties: {
				authenticator_data: {
					description:
						"Base64Url-encoded [authenticatorData](https://w3c.github.io/webauthn/#authenticator-data). Encoding: base64",
					type: "string",
				},
				client_data_json: {
					description:
						"Serialized [clientDataJSON](https://w3c.github.io/webauthn/#dom-authenticatorresponse-clientdatajson)",
					type: "string",
				},
				payload: {
					type: "string",
					parseJson: {
						type: "object",
						required: ["deadline", "nonce", "signer_id", "verifying_contract"],
						properties: {
							deadline: { type: "string" },
							intents: {
								description:
									"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
								type: "array",
								items: {
									oneOf: [
										{
											description: "See [`AddPublicKey`]",
											type: "object",
											required: ["intent", "public_key"],
											properties: {
												intent: { type: "string", enum: ["add_public_key"] },
												public_key: {
													examples: [
														"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
														"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
													],
													type: "string",
													description: "Encoding: base58",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`RemovePublicKey`]",
											type: "object",
											required: ["intent", "public_key"],
											properties: {
												intent: { type: "string", enum: ["remove_public_key"] },
												public_key: {
													examples: [
														"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
														"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
													],
													type: "string",
													description: "Encoding: base58",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`Transfer`]",
											type: "object",
											required: ["intent", "receiver_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["transfer"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description: "Message to pass to `mt_on_transfer`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
												tokens: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`FtWithdraw`]",
											type: "object",
											required: ["amount", "intent", "receiver_id", "token"],
											properties: {
												amount: { type: "string" },
												intent: { type: "string", enum: ["ft_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`NftWithdraw`]",
											type: "object",
											required: ["intent", "receiver_id", "token", "token_id"],
											properties: {
												intent: { type: "string", enum: ["nft_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												token_id: { type: "string" },
											},
											additionalProperties: false,
										},
										{
											description: "See [`MtWithdraw`]",
											type: "object",
											required: [
												"amounts",
												"intent",
												"receiver_id",
												"token",
												"token_ids",
											],
											properties: {
												amounts: { type: "array", items: { type: "string" } },
												intent: { type: "string", enum: ["mt_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												token_ids: { type: "array", items: { type: "string" } },
											},
											additionalProperties: false,
										},
										{
											description: "See [`NativeWithdraw`]",
											type: "object",
											required: ["amount", "intent", "receiver_id"],
											properties: {
												amount: { type: "string" },
												intent: { type: "string", enum: ["native_withdraw"] },
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`StorageDeposit`]",
											type: "object",
											required: [
												"amount",
												"contract_id",
												"deposit_for_account_id",
												"intent",
											],
											properties: {
												amount: { type: "string" },
												contract_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												deposit_for_account_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												intent: { type: "string", enum: ["storage_deposit"] },
											},
											additionalProperties: false,
										},
										{
											description: "See [`TokenDiff`]",
											type: "object",
											required: ["diff", "intent"],
											properties: {
												diff: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												intent: { type: "string", enum: ["token_diff"] },
												memo: { type: "string", nullable: true },
												referral: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
													nullable: true,
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`SetAuthByPredecessorId`]",
											type: "object",
											required: ["enabled", "intent"],
											properties: {
												enabled: { type: "boolean" },
												intent: {
													type: "string",
													enum: ["set_auth_by_predecessor_id"],
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`AuthCall`]",
											type: "object",
											required: ["contract_id", "intent", "msg"],
											properties: {
												attached_deposit: {
													description:
														"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
													type: "string",
													nullable: true,
												},
												contract_id: {
													description:
														"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
													type: "string",
												},
												intent: { type: "string", enum: ["auth_call"] },
												min_gas: {
													description:
														"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
											},
											additionalProperties: false,
										},
										{
											description:
												"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
											type: "object",
											required: ["intent", "receiver_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["imt_mint"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description: "Message to pass to `mt_on_transfer`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description: "Receiver of the minted tokens",
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
												tokens: {
													description:
														"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
										{
											description:
												"Burn a set of imt tokens, within the intents contract.",
											type: "object",
											required: ["intent", "minter_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["imt_burn"] },
												memo: { type: "string", nullable: true },
												minter_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												tokens: {
													description:
														"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
									],
								},
								nullable: true,
							},
							nonce: {
								examples: ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],
								type: "string",
								description: "Encoding: base64",
							},
							signer_id: {
								description:
									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
								type: "string",
							},
							verifying_contract: {
								description:
									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
								type: "string",
							},
						},
						additionalProperties: false,
					},
				},
				standard: { type: "string", enum: ["webauthn"] },
				public_key: {
					type: "string",
					pattern: "^p256:",
					description: "Encoding: base58",
				},
				signature: {
					type: "string",
					pattern: "^p256:",
					description: "Encoding: base58",
				},
			},
			description:
				"[COSE ES256 (-7) algorithm](https://www.iana.org/assignments/cose/cose.xhtml#algorithms): NIST P-256 curve (a.k.a secp256r1) over SHA-256",
			additionalProperties: false,
		},
		{
			description:
				"TonConnect: The standard for data signing in TON blockchain platform. For more details, refer to [TonConnect documentation](https://docs.tonconsole.com/academy/sign-data).",
			type: "object",
			required: [
				"address",
				"domain",
				"payload",
				"public_key",
				"signature",
				"standard",
				"timestamp",
			],
			properties: {
				address: {
					description:
						"Wallet address in either [Raw](https://docs.ton.org/v3/documentation/smart-contracts/addresses/address-formats#raw-address) representation or [user-friendly](https://docs.ton.org/v3/documentation/smart-contracts/addresses/address-formats#user-friendly-address) format",
					type: "string",
				},
				domain: { description: "dApp domain", type: "string" },
				payload: {
					description:
						"See <https://docs.tonconsole.com/academy/sign-data#choosing-the-right-format>",
					oneOf: [
						{
							type: "object",
							required: ["text", "type"],
							properties: {
								text: {
									type: "string",
									parseJson: {
										type: "object",
										required: [
											"deadline",
											"nonce",
											"signer_id",
											"verifying_contract",
										],
										properties: {
											deadline: { type: "string" },
											intents: {
												description:
													"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
												type: "array",
												items: {
													oneOf: [
														{
															description: "See [`AddPublicKey`]",
															type: "object",
															required: ["intent", "public_key"],
															properties: {
																intent: {
																	type: "string",
																	enum: ["add_public_key"],
																},
																public_key: {
																	examples: [
																		"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
																		"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
																	],
																	type: "string",
																	description: "Encoding: base58",
																},
															},
															additionalProperties: false,
														},
														{
															description: "See [`RemovePublicKey`]",
															type: "object",
															required: ["intent", "public_key"],
															properties: {
																intent: {
																	type: "string",
																	enum: ["remove_public_key"],
																},
																public_key: {
																	examples: [
																		"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
																		"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
																	],
																	type: "string",
																	description: "Encoding: base58",
																},
															},
															additionalProperties: false,
														},
														{
															description: "See [`Transfer`]",
															type: "object",
															required: ["intent", "receiver_id", "tokens"],
															properties: {
																intent: { type: "string", enum: ["transfer"] },
																memo: { type: "string", nullable: true },
																min_gas: {
																	description:
																		"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																	type: "string",
																	nullable: true,
																},
																msg: {
																	description:
																		"Message to pass to `mt_on_transfer`",
																	type: "string",
																	nullable: true,
																},
																receiver_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
																state_init: {
																	description:
																		"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
																	oneOf: [
																		{
																			type: "object",
																			required: ["code", "data", "version"],
																			properties: {
																				code: {
																					oneOf: [
																						{
																							type: "object",
																							required: ["hash"],
																							properties: {
																								hash: { type: "string" },
																							},
																							additionalProperties: false,
																						},
																						{
																							type: "object",
																							required: ["account_id"],
																							properties: {
																								account_id: {
																									description:
																										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																									type: "string",
																								},
																							},
																							additionalProperties: false,
																						},
																					],
																				},
																				data: {
																					type: "object",
																					additionalProperties: {
																						type: "string",
																					},
																					required: [],
																				},
																				version: {
																					type: "string",
																					enum: ["v1"],
																				},
																			},
																			additionalProperties: false,
																		},
																		{ type: "null" },
																	],
																},
																tokens: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
															},
															additionalProperties: false,
														},
														{
															description: "See [`FtWithdraw`]",
															type: "object",
															required: [
																"amount",
																"intent",
																"receiver_id",
																"token",
															],
															properties: {
																amount: { type: "string" },
																intent: {
																	type: "string",
																	enum: ["ft_withdraw"],
																},
																memo: { type: "string", nullable: true },
																min_gas: {
																	description:
																		"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																	type: "string",
																	nullable: true,
																},
																msg: {
																	description:
																		"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
																	type: "string",
																	nullable: true,
																},
																receiver_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
																storage_deposit: {
																	description:
																		"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
																	type: "string",
																	nullable: true,
																},
																token: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
															},
															additionalProperties: false,
														},
														{
															description: "See [`NftWithdraw`]",
															type: "object",
															required: [
																"intent",
																"receiver_id",
																"token",
																"token_id",
															],
															properties: {
																intent: {
																	type: "string",
																	enum: ["nft_withdraw"],
																},
																memo: { type: "string", nullable: true },
																min_gas: {
																	description:
																		"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																	type: "string",
																	nullable: true,
																},
																msg: {
																	description:
																		"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
																	type: "string",
																	nullable: true,
																},
																receiver_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
																storage_deposit: {
																	description:
																		"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
																	type: "string",
																	nullable: true,
																},
																token: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
																token_id: { type: "string" },
															},
															additionalProperties: false,
														},
														{
															description: "See [`MtWithdraw`]",
															type: "object",
															required: [
																"amounts",
																"intent",
																"receiver_id",
																"token",
																"token_ids",
															],
															properties: {
																amounts: {
																	type: "array",
																	items: { type: "string" },
																},
																intent: {
																	type: "string",
																	enum: ["mt_withdraw"],
																},
																memo: { type: "string", nullable: true },
																min_gas: {
																	description:
																		"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																	type: "string",
																	nullable: true,
																},
																msg: {
																	description:
																		"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
																	type: "string",
																	nullable: true,
																},
																receiver_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
																storage_deposit: {
																	description:
																		"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
																	type: "string",
																	nullable: true,
																},
																token: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
																token_ids: {
																	type: "array",
																	items: { type: "string" },
																},
															},
															additionalProperties: false,
														},
														{
															description: "See [`NativeWithdraw`]",
															type: "object",
															required: ["amount", "intent", "receiver_id"],
															properties: {
																amount: { type: "string" },
																intent: {
																	type: "string",
																	enum: ["native_withdraw"],
																},
																receiver_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
															},
															additionalProperties: false,
														},
														{
															description: "See [`StorageDeposit`]",
															type: "object",
															required: [
																"amount",
																"contract_id",
																"deposit_for_account_id",
																"intent",
															],
															properties: {
																amount: { type: "string" },
																contract_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
																deposit_for_account_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
																intent: {
																	type: "string",
																	enum: ["storage_deposit"],
																},
															},
															additionalProperties: false,
														},
														{
															description: "See [`TokenDiff`]",
															type: "object",
															required: ["diff", "intent"],
															properties: {
																diff: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																intent: {
																	type: "string",
																	enum: ["token_diff"],
																},
																memo: { type: "string", nullable: true },
																referral: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																	nullable: true,
																},
															},
															additionalProperties: false,
														},
														{
															description: "See [`SetAuthByPredecessorId`]",
															type: "object",
															required: ["enabled", "intent"],
															properties: {
																enabled: { type: "boolean" },
																intent: {
																	type: "string",
																	enum: ["set_auth_by_predecessor_id"],
																},
															},
															additionalProperties: false,
														},
														{
															description: "See [`AuthCall`]",
															type: "object",
															required: ["contract_id", "intent", "msg"],
															properties: {
																attached_deposit: {
																	description:
																		"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
																	type: "string",
																	nullable: true,
																},
																contract_id: {
																	description:
																		"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
																	type: "string",
																},
																intent: { type: "string", enum: ["auth_call"] },
																min_gas: {
																	description:
																		"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																	type: "string",
																	nullable: true,
																},
																msg: {
																	description:
																		"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
																	type: "string",
																},
																state_init: {
																	description:
																		"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
																	oneOf: [
																		{
																			type: "object",
																			required: ["code", "data", "version"],
																			properties: {
																				code: {
																					oneOf: [
																						{
																							type: "object",
																							required: ["hash"],
																							properties: {
																								hash: { type: "string" },
																							},
																							additionalProperties: false,
																						},
																						{
																							type: "object",
																							required: ["account_id"],
																							properties: {
																								account_id: {
																									description:
																										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																									type: "string",
																								},
																							},
																							additionalProperties: false,
																						},
																					],
																				},
																				data: {
																					type: "object",
																					additionalProperties: {
																						type: "string",
																					},
																					required: [],
																				},
																				version: {
																					type: "string",
																					enum: ["v1"],
																				},
																			},
																			additionalProperties: false,
																		},
																		{ type: "null" },
																	],
																},
															},
															additionalProperties: false,
														},
														{
															description:
																"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
															type: "object",
															required: ["intent", "receiver_id", "tokens"],
															properties: {
																intent: { type: "string", enum: ["imt_mint"] },
																memo: { type: "string", nullable: true },
																min_gas: {
																	description:
																		"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																	type: "string",
																	nullable: true,
																},
																msg: {
																	description:
																		"Message to pass to `mt_on_transfer`",
																	type: "string",
																	nullable: true,
																},
																receiver_id: {
																	description: "Receiver of the minted tokens",
																	type: "string",
																},
																state_init: {
																	description:
																		"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
																	oneOf: [
																		{
																			type: "object",
																			required: ["code", "data", "version"],
																			properties: {
																				code: {
																					oneOf: [
																						{
																							type: "object",
																							required: ["hash"],
																							properties: {
																								hash: { type: "string" },
																							},
																							additionalProperties: false,
																						},
																						{
																							type: "object",
																							required: ["account_id"],
																							properties: {
																								account_id: {
																									description:
																										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																									type: "string",
																								},
																							},
																							additionalProperties: false,
																						},
																					],
																				},
																				data: {
																					type: "object",
																					additionalProperties: {
																						type: "string",
																					},
																					required: [],
																				},
																				version: {
																					type: "string",
																					enum: ["v1"],
																				},
																			},
																			additionalProperties: false,
																		},
																		{ type: "null" },
																	],
																},
																tokens: {
																	description:
																		"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
															},
															additionalProperties: false,
														},
														{
															description:
																"Burn a set of imt tokens, within the intents contract.",
															type: "object",
															required: ["intent", "minter_id", "tokens"],
															properties: {
																intent: { type: "string", enum: ["imt_burn"] },
																memo: { type: "string", nullable: true },
																minter_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
																tokens: {
																	description:
																		"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
															},
															additionalProperties: false,
														},
													],
												},
												nullable: true,
											},
											nonce: {
												examples: [
													"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
												],
												type: "string",
												description: "Encoding: base64",
											},
											signer_id: {
												description:
													'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
												type: "string",
											},
											verifying_contract: {
												description:
													'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
												type: "string",
											},
										},
										additionalProperties: false,
									},
								},
								type: { type: "string", enum: ["text"] },
							},
							additionalProperties: false,
						},
					],
				},
				public_key: {
					type: "string",
					pattern: "^ed25519:",
					description: "Encoding: base58",
				},
				signature: {
					type: "string",
					pattern: "^ed25519:",
					description: "Encoding: base58",
				},
				standard: { type: "string", enum: ["ton_connect"] },
				timestamp: {
					description:
						"UNIX timestamp (in seconds or RFC3339) at the time of singing",
					anyOf: [
						{ type: "string", format: "date-time" },
						{ writeOnly: true, type: "integer", format: "int64" },
					],
				},
			},
			additionalProperties: false,
		},
		{
			description:
				"SEP-53: The standard for signing data off-chain for Stellar accounts. See [SEP-53](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0053.md)",
			type: "object",
			required: ["payload", "public_key", "signature", "standard"],
			properties: {
				payload: {
					type: "string",
					parseJson: {
						type: "object",
						required: ["deadline", "nonce", "signer_id", "verifying_contract"],
						properties: {
							deadline: { type: "string" },
							intents: {
								description:
									"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
								type: "array",
								items: {
									oneOf: [
										{
											description: "See [`AddPublicKey`]",
											type: "object",
											required: ["intent", "public_key"],
											properties: {
												intent: { type: "string", enum: ["add_public_key"] },
												public_key: {
													examples: [
														"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
														"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
													],
													type: "string",
													description: "Encoding: base58",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`RemovePublicKey`]",
											type: "object",
											required: ["intent", "public_key"],
											properties: {
												intent: { type: "string", enum: ["remove_public_key"] },
												public_key: {
													examples: [
														"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
														"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
													],
													type: "string",
													description: "Encoding: base58",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`Transfer`]",
											type: "object",
											required: ["intent", "receiver_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["transfer"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description: "Message to pass to `mt_on_transfer`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
												tokens: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`FtWithdraw`]",
											type: "object",
											required: ["amount", "intent", "receiver_id", "token"],
											properties: {
												amount: { type: "string" },
												intent: { type: "string", enum: ["ft_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`NftWithdraw`]",
											type: "object",
											required: ["intent", "receiver_id", "token", "token_id"],
											properties: {
												intent: { type: "string", enum: ["nft_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												token_id: { type: "string" },
											},
											additionalProperties: false,
										},
										{
											description: "See [`MtWithdraw`]",
											type: "object",
											required: [
												"amounts",
												"intent",
												"receiver_id",
												"token",
												"token_ids",
											],
											properties: {
												amounts: { type: "array", items: { type: "string" } },
												intent: { type: "string", enum: ["mt_withdraw"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												storage_deposit: {
													description:
														"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
													type: "string",
													nullable: true,
												},
												token: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												token_ids: { type: "array", items: { type: "string" } },
											},
											additionalProperties: false,
										},
										{
											description: "See [`NativeWithdraw`]",
											type: "object",
											required: ["amount", "intent", "receiver_id"],
											properties: {
												amount: { type: "string" },
												intent: { type: "string", enum: ["native_withdraw"] },
												receiver_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`StorageDeposit`]",
											type: "object",
											required: [
												"amount",
												"contract_id",
												"deposit_for_account_id",
												"intent",
											],
											properties: {
												amount: { type: "string" },
												contract_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												deposit_for_account_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												intent: { type: "string", enum: ["storage_deposit"] },
											},
											additionalProperties: false,
										},
										{
											description: "See [`TokenDiff`]",
											type: "object",
											required: ["diff", "intent"],
											properties: {
												diff: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												intent: { type: "string", enum: ["token_diff"] },
												memo: { type: "string", nullable: true },
												referral: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
													nullable: true,
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`SetAuthByPredecessorId`]",
											type: "object",
											required: ["enabled", "intent"],
											properties: {
												enabled: { type: "boolean" },
												intent: {
													type: "string",
													enum: ["set_auth_by_predecessor_id"],
												},
											},
											additionalProperties: false,
										},
										{
											description: "See [`AuthCall`]",
											type: "object",
											required: ["contract_id", "intent", "msg"],
											properties: {
												attached_deposit: {
													description:
														"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
													type: "string",
													nullable: true,
												},
												contract_id: {
													description:
														"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
													type: "string",
												},
												intent: { type: "string", enum: ["auth_call"] },
												min_gas: {
													description:
														"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description:
														"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
											},
											additionalProperties: false,
										},
										{
											description:
												"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
											type: "object",
											required: ["intent", "receiver_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["imt_mint"] },
												memo: { type: "string", nullable: true },
												min_gas: {
													description:
														"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
													type: "string",
													nullable: true,
												},
												msg: {
													description: "Message to pass to `mt_on_transfer`",
													type: "string",
													nullable: true,
												},
												receiver_id: {
													description: "Receiver of the minted tokens",
													type: "string",
												},
												state_init: {
													description:
														"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
													oneOf: [
														{
															type: "object",
															required: ["code", "data", "version"],
															properties: {
																code: {
																	oneOf: [
																		{
																			type: "object",
																			required: ["hash"],
																			properties: { hash: { type: "string" } },
																			additionalProperties: false,
																		},
																		{
																			type: "object",
																			required: ["account_id"],
																			properties: {
																				account_id: {
																					description:
																						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																					type: "string",
																				},
																			},
																			additionalProperties: false,
																		},
																	],
																},
																data: {
																	type: "object",
																	additionalProperties: { type: "string" },
																	required: [],
																},
																version: { type: "string", enum: ["v1"] },
															},
															additionalProperties: false,
														},
														{ type: "null" },
													],
												},
												tokens: {
													description:
														"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
										{
											description:
												"Burn a set of imt tokens, within the intents contract.",
											type: "object",
											required: ["intent", "minter_id", "tokens"],
											properties: {
												intent: { type: "string", enum: ["imt_burn"] },
												memo: { type: "string", nullable: true },
												minter_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												tokens: {
													description:
														"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
											},
											additionalProperties: false,
										},
									],
								},
								nullable: true,
							},
							nonce: {
								examples: ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],
								type: "string",
								description: "Encoding: base64",
							},
							signer_id: {
								description:
									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
								type: "string",
							},
							verifying_contract: {
								description:
									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
								type: "string",
							},
						},
						additionalProperties: false,
					},
				},
				public_key: {
					type: "string",
					pattern: "^ed25519:",
					description: "Encoding: base58",
				},
				signature: {
					type: "string",
					pattern: "^ed25519:",
					description: "Encoding: base58",
				},
				standard: { type: "string", enum: ["sep53"] },
			},
			additionalProperties: false,
		},
	],
};
export const MultiPayloadSchema =
	_MultiPayloadSchemaCheck as unknown as JSONSchemaType<Types.MultiPayload__Parsed>;

export const NativeWithdrawSchema: JSONSchemaType<Types.NativeWithdraw> = {
	description:
		"Withdraw native tokens (NEAR) from the intents contract to a given external account id (external being outside of intents). This will subtract from the account's wNEAR balance, and will be sent to the account specified as native NEAR. NOTE: the `wNEAR` will not be refunded in case of fail (e.g. `receiver_id` account does not exist).",
	type: "object",
	required: ["amount", "receiver_id"],
	properties: {
		amount: { type: "string" },
		receiver_id: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
	},
	additionalProperties: false,
};

export const Nep413DefuseMessageFor_DefuseIntentsSchema: JSONSchemaType<Types.Nep413DefuseMessageFor_DefuseIntents> =
	{
		type: "object",
		required: ["deadline", "signer_id"],
		properties: {
			deadline: { type: "string" },
			intents: {
				description:
					"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
				type: "array",
				items: {
					oneOf: [
						{
							description: "See [`AddPublicKey`]",
							type: "object",
							required: ["intent", "public_key"],
							properties: {
								intent: { type: "string", enum: ["add_public_key"] },
								public_key: {
									examples: [
										"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
										"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
									],
									type: "string",
									description: "Encoding: base58",
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`RemovePublicKey`]",
							type: "object",
							required: ["intent", "public_key"],
							properties: {
								intent: { type: "string", enum: ["remove_public_key"] },
								public_key: {
									examples: [
										"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
										"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
									],
									type: "string",
									description: "Encoding: base58",
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`Transfer`]",
							type: "object",
							required: ["intent", "receiver_id", "tokens"],
							properties: {
								intent: { type: "string", enum: ["transfer"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description: "Message to pass to `mt_on_transfer`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								state_init: {
									description:
										"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
									oneOf: [
										{
											type: "object",
											required: ["code", "data", "version"],
											properties: {
												code: {
													oneOf: [
														{
															type: "object",
															required: ["hash"],
															properties: { hash: { type: "string" } },
															additionalProperties: false,
														},
														{
															type: "object",
															required: ["account_id"],
															properties: {
																account_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
															},
															additionalProperties: false,
														},
													],
												},
												data: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												version: { type: "string", enum: ["v1"] },
											},
											additionalProperties: false,
										},
										{ type: "null" },
									],
								},
								tokens: {
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`FtWithdraw`]",
							type: "object",
							required: ["amount", "intent", "receiver_id", "token"],
							properties: {
								amount: { type: "string" },
								intent: { type: "string", enum: ["ft_withdraw"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description:
										"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								storage_deposit: {
									description:
										"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
									type: "string",
									nullable: true,
								},
								token: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`NftWithdraw`]",
							type: "object",
							required: ["intent", "receiver_id", "token", "token_id"],
							properties: {
								intent: { type: "string", enum: ["nft_withdraw"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description:
										"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								storage_deposit: {
									description:
										"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
									type: "string",
									nullable: true,
								},
								token: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								token_id: { type: "string" },
							},
							additionalProperties: false,
						},
						{
							description: "See [`MtWithdraw`]",
							type: "object",
							required: [
								"amounts",
								"intent",
								"receiver_id",
								"token",
								"token_ids",
							],
							properties: {
								amounts: { type: "array", items: { type: "string" } },
								intent: { type: "string", enum: ["mt_withdraw"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description:
										"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								storage_deposit: {
									description:
										"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
									type: "string",
									nullable: true,
								},
								token: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								token_ids: { type: "array", items: { type: "string" } },
							},
							additionalProperties: false,
						},
						{
							description: "See [`NativeWithdraw`]",
							type: "object",
							required: ["amount", "intent", "receiver_id"],
							properties: {
								amount: { type: "string" },
								intent: { type: "string", enum: ["native_withdraw"] },
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`StorageDeposit`]",
							type: "object",
							required: [
								"amount",
								"contract_id",
								"deposit_for_account_id",
								"intent",
							],
							properties: {
								amount: { type: "string" },
								contract_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								deposit_for_account_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								intent: { type: "string", enum: ["storage_deposit"] },
							},
							additionalProperties: false,
						},
						{
							description: "See [`TokenDiff`]",
							type: "object",
							required: ["diff", "intent"],
							properties: {
								diff: {
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
								intent: { type: "string", enum: ["token_diff"] },
								memo: { type: "string", nullable: true },
								referral: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
									nullable: true,
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`SetAuthByPredecessorId`]",
							type: "object",
							required: ["enabled", "intent"],
							properties: {
								enabled: { type: "boolean" },
								intent: {
									type: "string",
									enum: ["set_auth_by_predecessor_id"],
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`AuthCall`]",
							type: "object",
							required: ["contract_id", "intent", "msg"],
							properties: {
								attached_deposit: {
									description:
										"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
									type: "string",
									nullable: true,
								},
								contract_id: {
									description:
										"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
									type: "string",
								},
								intent: { type: "string", enum: ["auth_call"] },
								min_gas: {
									description:
										"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description:
										"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
									type: "string",
								},
								state_init: {
									description:
										"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
									oneOf: [
										{
											type: "object",
											required: ["code", "data", "version"],
											properties: {
												code: {
													oneOf: [
														{
															type: "object",
															required: ["hash"],
															properties: { hash: { type: "string" } },
															additionalProperties: false,
														},
														{
															type: "object",
															required: ["account_id"],
															properties: {
																account_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
															},
															additionalProperties: false,
														},
													],
												},
												data: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												version: { type: "string", enum: ["v1"] },
											},
											additionalProperties: false,
										},
										{ type: "null" },
									],
								},
							},
							additionalProperties: false,
						},
						{
							description:
								"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
							type: "object",
							required: ["intent", "receiver_id", "tokens"],
							properties: {
								intent: { type: "string", enum: ["imt_mint"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description: "Message to pass to `mt_on_transfer`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description: "Receiver of the minted tokens",
									type: "string",
								},
								state_init: {
									description:
										"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
									oneOf: [
										{
											type: "object",
											required: ["code", "data", "version"],
											properties: {
												code: {
													oneOf: [
														{
															type: "object",
															required: ["hash"],
															properties: { hash: { type: "string" } },
															additionalProperties: false,
														},
														{
															type: "object",
															required: ["account_id"],
															properties: {
																account_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
															},
															additionalProperties: false,
														},
													],
												},
												data: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												version: { type: "string", enum: ["v1"] },
											},
											additionalProperties: false,
										},
										{ type: "null" },
									],
								},
								tokens: {
									description:
										"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
							},
							additionalProperties: false,
						},
						{
							description:
								"Burn a set of imt tokens, within the intents contract.",
							type: "object",
							required: ["intent", "minter_id", "tokens"],
							properties: {
								intent: { type: "string", enum: ["imt_burn"] },
								memo: { type: "string", nullable: true },
								minter_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								tokens: {
									description:
										"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
							},
							additionalProperties: false,
						},
					],
				},
				nullable: true,
			},
			signer_id: {
				description:
					'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
				type: "string",
			},
		},
		additionalProperties: false,
	};

export const Nep413PayloadSchema: JSONSchemaType<Types.Nep413Payload> = {
	description:
		"See [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)",
	type: "object",
	required: ["message", "nonce", "recipient"],
	properties: {
		callbackUrl: { type: "string", nullable: true },
		message: { type: "string" },
		nonce: { type: "string", description: "Encoding: base64" },
		recipient: { type: "string" },
	},
	additionalProperties: false,
};

export const NftWithdrawSchema: JSONSchemaType<Types.NftWithdraw> = {
	description:
		"Withdraw given NFT tokens from the intents contract to a given external account id (external being outside of intents).",
	type: "object",
	required: ["receiver_id", "token", "token_id"],
	properties: {
		memo: { type: "string", nullable: true },
		min_gas: {
			description:
				"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
			type: "string",
			nullable: true,
		},
		msg: {
			description:
				"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
			type: "string",
			nullable: true,
		},
		receiver_id: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
		storage_deposit: {
			description:
				"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
			type: "string",
			nullable: true,
		},
		token: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
		token_id: { type: "string" },
	},
	additionalProperties: false,
};

export const PermissionedAccountsSchema: JSONSchemaType<Types.PermissionedAccounts> =
	{
		description:
			'Collects super admin accounts and accounts that have been granted permissions defined by `AccessControlRole`.\n\n# Data structure\n\nAssume `AccessControlRole` is derived for the following enum, which is then passed as `role` attribute to `AccessControllable`.\n\n```rust pub enum Role { PauseManager, UnpauseManager, } ```\n\nThen the returned data has the following structure:\n\n```ignore PermissionedAccounts { super_admins: vec!["acc1.near", "acc2.near"], roles: HashMap::from([ ("PauseManager", PermissionedAccountsPerRole { admins: vec!["acc3.near", "acc4.near"], grantees: vec!["acc5.near", "acc6.near"], }), ("UnpauseManager", PermissionedAccountsPerRole { admins: vec!["acc7.near", "acc8.near"], grantees: vec!["acc9.near", "acc10.near"], }), ]) } ```\n\n# Uniqueness and ordering\n\nAccount ids returned in vectors are unique but not ordered.',
		type: "object",
		required: ["roles", "super_admins"],
		properties: {
			roles: {
				description: "The admins and grantees of all roles.",
				type: "object",
				additionalProperties: {
					description:
						"Collects all admins and grantees of a role.\n\n# Uniqueness and ordering\n\nAccount ids returned in vectors are unique but not ordered.",
					type: "object",
					required: ["admins", "grantees"],
					properties: {
						admins: {
							description:
								"The accounts that have admin permissions for the role.",
							type: "array",
							items: {
								description:
									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
								type: "string",
							},
						},
						grantees: {
							description: "The accounts that have been granted the role.",
							type: "array",
							items: {
								description:
									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
								type: "string",
							},
						},
					},
					additionalProperties: false,
				},
				required: [],
			},
			super_admins: {
				description: "The accounts that have super admin permissions.",
				type: "array",
				items: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
			},
		},
		additionalProperties: false,
	};

export const PermissionedAccountsPerRoleSchema: JSONSchemaType<Types.PermissionedAccountsPerRole> =
	{
		description:
			"Collects all admins and grantees of a role.\n\n# Uniqueness and ordering\n\nAccount ids returned in vectors are unique but not ordered.",
		type: "object",
		required: ["admins", "grantees"],
		properties: {
			admins: {
				description: "The accounts that have admin permissions for the role.",
				type: "array",
				items: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
			},
			grantees: {
				description: "The accounts that have been granted the role.",
				type: "array",
				items: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
			},
		},
		additionalProperties: false,
	};

export const PickFirstDateTimeint64Schema: JSONSchemaType<Types.PickFirstDateTimeint64> =
	{
		anyOf: [
			{ type: "string", format: "date-time" },
			{ writeOnly: true, type: "integer", format: "int64" },
		],
	};

export const PipsSchema: JSONSchemaType<Types.Pips> = {
	description: "1 pip == 1/100th of bip == 0.0001%",
	type: "integer",
	format: "uint32",
	minimum: 0,
};

export const RolesConfigSchema: JSONSchemaType<Types.RolesConfig> = {
	type: "object",
	properties: {
		admins: {
			default: {},
			type: "object",
			additionalProperties: {
				type: "array",
				items: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
				uniqueItems: true,
			},
			required: [],
		},
		grantees: {
			default: {},
			type: "object",
			additionalProperties: {
				type: "array",
				items: {
					description:
						'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
					type: "string",
				},
				uniqueItems: true,
			},
			required: [],
		},
		super_admins: {
			default: [],
			type: "array",
			items: {
				description:
					'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
				type: "string",
			},
			uniqueItems: true,
		},
	},
	additionalProperties: false,
};

// Cast allowed here due to AJV v8 limitation: Optional union property (invariant_violated?: InvariantViolated | null) - AJV limitation
// See: https://github.com/ajv-validator/ajv/issues/2132
export const SimulationOutputSchema = {
	type: "object",
	required: ["intents_executed", "logs", "min_deadline", "state"],
	properties: {
		intents_executed: {
			type: "array",
			items: {
				type: "object",
				required: ["account_id", "intent_hash", "nonce"],
				properties: {
					account_id: {
						description:
							'Account identifier. This is the human readable UTF-8 string which is used internally to index accounts on the network and their respective state.\n\nThis is the "referenced" version of the account ID. It is to [`AccountId`] what [`str`] is to [`String`], and works quite similarly to [`Path`]. Like with [`str`] and [`Path`], you can\'t have a value of type `AccountIdRef`, but you can have a reference like `&AccountIdRef` or `&mut AccountIdRef`.\n\nThis type supports zero-copy deserialization offered by [`serde`](https://docs.rs/serde/), but cannot do the same for [`borsh`](https://docs.rs/borsh/) since the latter does not support zero-copy.\n\n# Examples ``` use near_account_id::{AccountId, AccountIdRef}; use std::convert::{TryFrom, TryInto};\n\n// Construction let alice = AccountIdRef::new("alice.near").unwrap(); assert!(AccountIdRef::new("invalid.").is_err()); ```\n\n[`FromStr`]: std::str::FromStr [`Path`]: std::path::Path',
						type: "string",
					},
					intent_hash: { type: "string", description: "Encoding: base58" },
					nonce: { type: "string", description: "Encoding: base64" },
				},
				additionalProperties: false,
			},
		},
		invariant_violated: {
			description:
				"Unmatched token deltas needed to keep the invariant. If not empty, can be used along with fee to calculate `token_diff` closure.",
			oneOf: [
				{
					type: "object",
					required: ["error", "unmatched_deltas"],
					properties: {
						error: { type: "string", enum: ["unmatched_deltas"] },
						unmatched_deltas: {
							type: "object",
							additionalProperties: { type: "string" },
							required: [],
						},
					},
					additionalProperties: false,
				},
				{
					type: "object",
					required: ["error"],
					properties: { error: { type: "string", enum: ["overflow"] } },
					additionalProperties: false,
				},
				{ type: "null" },
			],
		},
		logs: { type: "array", items: { type: "string" } },
		min_deadline: { type: "string" },
		state: {
			description: "Additional info about current state",
			type: "object",
			required: ["current_salt", "fee"],
			properties: {
				current_salt: { type: "string", description: "Encoding: hex" },
				fee: {
					description: "1 pip == 1/100th of bip == 0.0001%",
					type: "integer",
					format: "uint32",
					minimum: 0,
				},
			},
			additionalProperties: false,
		},
	},
	additionalProperties: false,
} as unknown as JSONSchemaType<Types.SimulationOutput>;

export const StateInitSchema: JSONSchemaType<Types.StateInit> = {
	oneOf: [
		{
			type: "object",
			required: ["code", "data", "version"],
			properties: {
				code: {
					oneOf: [
						{
							type: "object",
							required: ["hash"],
							properties: { hash: { type: "string" } },
							additionalProperties: false,
						},
						{
							type: "object",
							required: ["account_id"],
							properties: {
								account_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
							},
							additionalProperties: false,
						},
					],
				},
				data: {
					type: "object",
					additionalProperties: { type: "string" },
					required: [],
				},
				version: { type: "string", enum: ["v1"] },
			},
			additionalProperties: false,
		},
	],
};

export const StateOutputSchema: JSONSchemaType<Types.StateOutput> = {
	type: "object",
	required: ["current_salt", "fee"],
	properties: {
		current_salt: { type: "string", description: "Encoding: hex" },
		fee: {
			description: "1 pip == 1/100th of bip == 0.0001%",
			type: "integer",
			format: "uint32",
			minimum: 0,
		},
	},
	additionalProperties: false,
};

export const StorageDepositSchema: JSONSchemaType<Types.StorageDeposit> = {
	description:
		"Make [NEP-145](https://nomicon.io/Standards/StorageManagement#nep-145) `storage_deposit` for an `account_id` on `contract_id`. The `amount` will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in any case.\n\nWARNING: use this intent only if paying storage_deposit is not a prerequisite for other intents to succeed. If some intent (e.g. ft_withdraw) requires storage_deposit, then use storage_deposit field of corresponding intent instead of adding a separate `StorageDeposit` intent. This is due to the fact that intents that fire `Promise`s are not guaranteed to be executed sequentially, in the order of the provided intents in `DefuseIntents`.",
	type: "object",
	required: ["amount", "contract_id", "deposit_for_account_id"],
	properties: {
		amount: { type: "string" },
		contract_id: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
		deposit_for_account_id: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
	},
	additionalProperties: false,
};

export const StringSchema: JSONSchemaType<Types.String> = { type: "string" };

export const Tip191PayloadSchema: JSONSchemaType<Types.Tip191Payload> = {
	description:
		"See [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md)",
	type: "string",
};

export const TokenSchema: JSONSchemaType<Types.Token> = {
	type: "object",
	required: ["token_id"],
	properties: {
		owner_id: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
			nullable: true,
		},
		token_id: { type: "string" },
	},
	additionalProperties: false,
};

export const TonConnectPayloadSchemaSchema: JSONSchemaType<Types.TonConnectPayloadSchema> =
	{
		description:
			"See <https://docs.tonconsole.com/academy/sign-data#choosing-the-right-format>",
		oneOf: [
			{
				type: "object",
				required: ["text", "type"],
				properties: {
					text: { type: "string" },
					type: { type: "string", enum: ["text"] },
				},
				additionalProperties: false,
			},
		],
	};

export const IntentAddPublicKeySchema: JSONSchemaType<Types.IntentAddPublicKey> =
	{
		description: "See [`AddPublicKey`]",
		type: "object",
		required: ["intent", "public_key"],
		properties: {
			intent: { type: "string", enum: ["add_public_key"] },
			public_key: {
				examples: [
					"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
					"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
				],
				type: "string",
				description: "Encoding: base58",
			},
		},
		additionalProperties: false,
	};

export const IntentRemovePublicKeySchema: JSONSchemaType<Types.IntentRemovePublicKey> =
	{
		description: "See [`RemovePublicKey`]",
		type: "object",
		required: ["intent", "public_key"],
		properties: {
			intent: { type: "string", enum: ["remove_public_key"] },
			public_key: {
				examples: [
					"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
					"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
				],
				type: "string",
				description: "Encoding: base58",
			},
		},
		additionalProperties: false,
	};

export const IntentTransferSchema: JSONSchemaType<Types.IntentTransfer> = {
	description: "See [`Transfer`]",
	type: "object",
	required: ["intent", "receiver_id", "tokens"],
	properties: {
		intent: { type: "string", enum: ["transfer"] },
		memo: { type: "string", nullable: true },
		min_gas: {
			description:
				"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
			type: "string",
			nullable: true,
		},
		msg: {
			description: "Message to pass to `mt_on_transfer`",
			type: "string",
			nullable: true,
		},
		receiver_id: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
		state_init: {
			description:
				"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
			oneOf: [
				{
					type: "object",
					required: ["code", "data", "version"],
					properties: {
						code: {
							oneOf: [
								{
									type: "object",
									required: ["hash"],
									properties: { hash: { type: "string" } },
									additionalProperties: false,
								},
								{
									type: "object",
									required: ["account_id"],
									properties: {
										account_id: {
											description:
												'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
											type: "string",
										},
									},
									additionalProperties: false,
								},
							],
						},
						data: {
							type: "object",
							additionalProperties: { type: "string" },
							required: [],
						},
						version: { type: "string", enum: ["v1"] },
					},
					additionalProperties: false,
				},
				{ type: "null" },
			],
		},
		tokens: {
			type: "object",
			additionalProperties: { type: "string" },
			required: [],
		},
	},
	additionalProperties: false,
};

export const IntentFtWithdrawSchema: JSONSchemaType<Types.IntentFtWithdraw> = {
	description: "See [`FtWithdraw`]",
	type: "object",
	required: ["amount", "intent", "receiver_id", "token"],
	properties: {
		amount: { type: "string" },
		intent: { type: "string", enum: ["ft_withdraw"] },
		memo: { type: "string", nullable: true },
		min_gas: {
			description:
				"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
			type: "string",
			nullable: true,
		},
		msg: {
			description:
				"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
			type: "string",
			nullable: true,
		},
		receiver_id: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
		storage_deposit: {
			description:
				"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
			type: "string",
			nullable: true,
		},
		token: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
	},
	additionalProperties: false,
};

export const IntentNftWithdrawSchema: JSONSchemaType<Types.IntentNftWithdraw> =
	{
		description: "See [`NftWithdraw`]",
		type: "object",
		required: ["intent", "receiver_id", "token", "token_id"],
		properties: {
			intent: { type: "string", enum: ["nft_withdraw"] },
			memo: { type: "string", nullable: true },
			min_gas: {
				description:
					"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
				type: "string",
				nullable: true,
			},
			msg: {
				description:
					"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
				type: "string",
				nullable: true,
			},
			receiver_id: {
				description:
					'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
				type: "string",
			},
			storage_deposit: {
				description:
					"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
				type: "string",
				nullable: true,
			},
			token: {
				description:
					'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
				type: "string",
			},
			token_id: { type: "string" },
		},
		additionalProperties: false,
	};

export const IntentMtWithdrawSchema: JSONSchemaType<Types.IntentMtWithdraw> = {
	description: "See [`MtWithdraw`]",
	type: "object",
	required: ["amounts", "intent", "receiver_id", "token", "token_ids"],
	properties: {
		amounts: { type: "array", items: { type: "string" } },
		intent: { type: "string", enum: ["mt_withdraw"] },
		memo: { type: "string", nullable: true },
		min_gas: {
			description:
				"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
			type: "string",
			nullable: true,
		},
		msg: {
			description:
				"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
			type: "string",
			nullable: true,
		},
		receiver_id: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
		storage_deposit: {
			description:
				"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
			type: "string",
			nullable: true,
		},
		token: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
		token_ids: { type: "array", items: { type: "string" } },
	},
	additionalProperties: false,
};

export const IntentNativeWithdrawSchema: JSONSchemaType<Types.IntentNativeWithdraw> =
	{
		description: "See [`NativeWithdraw`]",
		type: "object",
		required: ["amount", "intent", "receiver_id"],
		properties: {
			amount: { type: "string" },
			intent: { type: "string", enum: ["native_withdraw"] },
			receiver_id: {
				description:
					'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
				type: "string",
			},
		},
		additionalProperties: false,
	};

export const IntentStorageDepositSchema: JSONSchemaType<Types.IntentStorageDeposit> =
	{
		description: "See [`StorageDeposit`]",
		type: "object",
		required: ["amount", "contract_id", "deposit_for_account_id", "intent"],
		properties: {
			amount: { type: "string" },
			contract_id: {
				description:
					'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
				type: "string",
			},
			deposit_for_account_id: {
				description:
					'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
				type: "string",
			},
			intent: { type: "string", enum: ["storage_deposit"] },
		},
		additionalProperties: false,
	};

export const IntentTokenDiffSchema: JSONSchemaType<Types.IntentTokenDiff> = {
	description: "See [`TokenDiff`]",
	type: "object",
	required: ["diff", "intent"],
	properties: {
		diff: {
			type: "object",
			additionalProperties: { type: "string" },
			required: [],
		},
		intent: { type: "string", enum: ["token_diff"] },
		memo: { type: "string", nullable: true },
		referral: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
			nullable: true,
		},
	},
	additionalProperties: false,
};

export const IntentSetAuthByPredecessorIdSchema: JSONSchemaType<Types.IntentSetAuthByPredecessorId> =
	{
		description: "See [`SetAuthByPredecessorId`]",
		type: "object",
		required: ["enabled", "intent"],
		properties: {
			enabled: { type: "boolean" },
			intent: { type: "string", enum: ["set_auth_by_predecessor_id"] },
		},
		additionalProperties: false,
	};

export const IntentAuthCallSchema: JSONSchemaType<Types.IntentAuthCall> = {
	description: "See [`AuthCall`]",
	type: "object",
	required: ["contract_id", "intent", "msg"],
	properties: {
		attached_deposit: {
			description:
				"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
			type: "string",
			nullable: true,
		},
		contract_id: {
			description:
				"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
			type: "string",
		},
		intent: { type: "string", enum: ["auth_call"] },
		min_gas: {
			description:
				"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
			type: "string",
			nullable: true,
		},
		msg: {
			description:
				"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
			type: "string",
		},
		state_init: {
			description:
				"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
			oneOf: [
				{
					type: "object",
					required: ["code", "data", "version"],
					properties: {
						code: {
							oneOf: [
								{
									type: "object",
									required: ["hash"],
									properties: { hash: { type: "string" } },
									additionalProperties: false,
								},
								{
									type: "object",
									required: ["account_id"],
									properties: {
										account_id: {
											description:
												'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
											type: "string",
										},
									},
									additionalProperties: false,
								},
							],
						},
						data: {
							type: "object",
							additionalProperties: { type: "string" },
							required: [],
						},
						version: { type: "string", enum: ["v1"] },
					},
					additionalProperties: false,
				},
				{ type: "null" },
			],
		},
	},
	additionalProperties: false,
};

export const IntentImtMintSchema: JSONSchemaType<Types.IntentImtMint> = {
	description:
		"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
	type: "object",
	required: ["intent", "receiver_id", "tokens"],
	properties: {
		intent: { type: "string", enum: ["imt_mint"] },
		memo: { type: "string", nullable: true },
		min_gas: {
			description:
				"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
			type: "string",
			nullable: true,
		},
		msg: {
			description: "Message to pass to `mt_on_transfer`",
			type: "string",
			nullable: true,
		},
		receiver_id: {
			description: "Receiver of the minted tokens",
			type: "string",
		},
		state_init: {
			description:
				"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
			oneOf: [
				{
					type: "object",
					required: ["code", "data", "version"],
					properties: {
						code: {
							oneOf: [
								{
									type: "object",
									required: ["hash"],
									properties: { hash: { type: "string" } },
									additionalProperties: false,
								},
								{
									type: "object",
									required: ["account_id"],
									properties: {
										account_id: {
											description:
												'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
											type: "string",
										},
									},
									additionalProperties: false,
								},
							],
						},
						data: {
							type: "object",
							additionalProperties: { type: "string" },
							required: [],
						},
						version: { type: "string", enum: ["v1"] },
					},
					additionalProperties: false,
				},
				{ type: "null" },
			],
		},
		tokens: {
			description:
				"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
			type: "object",
			additionalProperties: { type: "string" },
			required: [],
		},
	},
	additionalProperties: false,
};

export const IntentImtBurnSchema: JSONSchemaType<Types.IntentImtBurn> = {
	description: "Burn a set of imt tokens, within the intents contract.",
	type: "object",
	required: ["intent", "minter_id", "tokens"],
	properties: {
		intent: { type: "string", enum: ["imt_burn"] },
		memo: { type: "string", nullable: true },
		minter_id: {
			description:
				'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
			type: "string",
		},
		tokens: {
			description:
				"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
			type: "object",
			additionalProperties: { type: "string" },
			required: [],
		},
	},
	additionalProperties: false,
};

export const InvariantViolatedUnmatchedDeltasSchema: JSONSchemaType<Types.InvariantViolatedUnmatchedDeltas> =
	{
		type: "object",
		required: ["error", "unmatched_deltas"],
		properties: {
			error: { type: "string", enum: ["unmatched_deltas"] },
			unmatched_deltas: {
				type: "object",
				additionalProperties: { type: "string" },
				required: [],
			},
		},
		additionalProperties: false,
	};

export const InvariantViolatedOverflowSchema: JSONSchemaType<Types.InvariantViolatedOverflow> =
	{
		type: "object",
		required: ["error"],
		properties: { error: { type: "string", enum: ["overflow"] } },
		additionalProperties: false,
	};

export const MultiPayloadNep413Schema: JSONSchemaType<Types.MultiPayloadNep413> =
	{
		description:
			"NEP-413: The standard for message signing in Near Protocol. For more details, refer to [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md).",
		type: "object",
		required: ["payload", "public_key", "signature", "standard"],
		properties: {
			payload: {
				description:
					"See [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)",
				type: "object",
				required: ["message", "nonce", "recipient"],
				properties: {
					callbackUrl: { type: "string", nullable: true },
					message: { type: "string" },
					nonce: { type: "string", description: "Encoding: base64" },
					recipient: { type: "string" },
				},
				additionalProperties: false,
			},
			public_key: {
				type: "string",
				pattern: "^ed25519:",
				description: "Encoding: base58",
			},
			signature: {
				type: "string",
				pattern: "^ed25519:",
				description: "Encoding: base58",
			},
			standard: { type: "string", enum: ["nep413"] },
		},
		additionalProperties: false,
	};

export const MultiPayloadErc191Schema: JSONSchemaType<Types.MultiPayloadErc191> =
	{
		description:
			"ERC-191: The standard for message signing in Ethereum, commonly used with `personal_sign()`. For more details, refer to [EIP-191](https://eips.ethereum.org/EIPS/eip-191).",
		type: "object",
		required: ["payload", "signature", "standard"],
		properties: {
			payload: {
				description:
					"See [ERC-191](https://github.com/ethereum/ercs/blob/master/ERCS/erc-191.md)",
				type: "string",
			},
			signature: {
				description:
					"There is no public key member because the public key can be recovered via `ecrecover()` knowing the data and the signature. Encoding: base58",
				type: "string",
				pattern: "^secp256k1:",
			},
			standard: { type: "string", enum: ["erc191"] },
		},
		additionalProperties: false,
	};

export const MultiPayloadTip191Schema: JSONSchemaType<Types.MultiPayloadTip191> =
	{
		description:
			"TIP-191: The standard for message signing in Tron. For more details, refer to [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md).",
		type: "object",
		required: ["payload", "signature", "standard"],
		properties: {
			payload: {
				description:
					"See [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md)",
				type: "string",
			},
			signature: {
				description:
					"There is no public key member because the public key can be recovered via `ecrecover()` knowing the data and the signature. Encoding: base58",
				type: "string",
				pattern: "^secp256k1:",
			},
			standard: { type: "string", enum: ["tip191"] },
		},
		additionalProperties: false,
	};

export const MultiPayloadRawEd25519Schema: JSONSchemaType<Types.MultiPayloadRawEd25519> =
	{
		description:
			"Raw Ed25519: The standard used by Solana Phantom wallets for message signing. For more details, refer to [Phantom Wallet's documentation](https://docs.phantom.com/solana/signing-a-message).",
		type: "object",
		required: ["payload", "public_key", "signature", "standard"],
		properties: {
			payload: { type: "string" },
			public_key: {
				type: "string",
				pattern: "^ed25519:",
				description: "Encoding: base58",
			},
			signature: {
				type: "string",
				pattern: "^ed25519:",
				description: "Encoding: base58",
			},
			standard: { type: "string", enum: ["raw_ed25519"] },
		},
		additionalProperties: false,
	};

export const MultiPayloadWebauthnSchema: JSONSchemaType<Types.MultiPayloadWebauthn> =
	{
		type: "object",
		required: [
			"authenticator_data",
			"client_data_json",
			"payload",
			"standard",
			"public_key",
			"signature",
		],
		properties: {
			authenticator_data: {
				description:
					"Base64Url-encoded [authenticatorData](https://w3c.github.io/webauthn/#authenticator-data). Encoding: base64",
				type: "string",
			},
			client_data_json: {
				description:
					"Serialized [clientDataJSON](https://w3c.github.io/webauthn/#dom-authenticatorresponse-clientdatajson)",
				type: "string",
			},
			payload: { type: "string" },
			standard: { type: "string", enum: ["webauthn"] },
			public_key: {
				type: "string",
				pattern: "^p256:",
				description: "Encoding: base58",
			},
			signature: {
				type: "string",
				pattern: "^p256:",
				description: "Encoding: base58",
			},
		},
		description:
			"[COSE ES256 (-7) algorithm](https://www.iana.org/assignments/cose/cose.xhtml#algorithms): NIST P-256 curve (a.k.a secp256r1) over SHA-256",
		additionalProperties: false,
	};

export const MultiPayloadTonConnectSchema: JSONSchemaType<Types.MultiPayloadTonConnect> =
	{
		description:
			"TonConnect: The standard for data signing in TON blockchain platform. For more details, refer to [TonConnect documentation](https://docs.tonconsole.com/academy/sign-data).",
		type: "object",
		required: [
			"address",
			"domain",
			"payload",
			"public_key",
			"signature",
			"standard",
			"timestamp",
		],
		properties: {
			address: {
				description:
					"Wallet address in either [Raw](https://docs.ton.org/v3/documentation/smart-contracts/addresses/address-formats#raw-address) representation or [user-friendly](https://docs.ton.org/v3/documentation/smart-contracts/addresses/address-formats#user-friendly-address) format",
				type: "string",
			},
			domain: { description: "dApp domain", type: "string" },
			payload: {
				description:
					"See <https://docs.tonconsole.com/academy/sign-data#choosing-the-right-format>",
				oneOf: [
					{
						type: "object",
						required: ["text", "type"],
						properties: {
							text: { type: "string" },
							type: { type: "string", enum: ["text"] },
						},
						additionalProperties: false,
					},
				],
			},
			public_key: {
				type: "string",
				pattern: "^ed25519:",
				description: "Encoding: base58",
			},
			signature: {
				type: "string",
				pattern: "^ed25519:",
				description: "Encoding: base58",
			},
			standard: { type: "string", enum: ["ton_connect"] },
			timestamp: {
				description:
					"UNIX timestamp (in seconds or RFC3339) at the time of singing",
				anyOf: [
					{ type: "string", format: "date-time" },
					{ writeOnly: true, type: "integer", format: "int64" },
				],
			},
		},
		additionalProperties: false,
	};

export const MultiPayloadSep53Schema: JSONSchemaType<Types.MultiPayloadSep53> =
	{
		description:
			"SEP-53: The standard for signing data off-chain for Stellar accounts. See [SEP-53](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0053.md)",
		type: "object",
		required: ["payload", "public_key", "signature", "standard"],
		properties: {
			payload: { type: "string" },
			public_key: {
				type: "string",
				pattern: "^ed25519:",
				description: "Encoding: base58",
			},
			signature: {
				type: "string",
				pattern: "^ed25519:",
				description: "Encoding: base58",
			},
			standard: { type: "string", enum: ["sep53"] },
		},
		additionalProperties: false,
	};

export const StateInitV1Schema: JSONSchemaType<Types.StateInitV1> = {
	type: "object",
	required: ["code", "data", "version"],
	properties: {
		code: {
			oneOf: [
				{
					type: "object",
					required: ["hash"],
					properties: { hash: { type: "string" } },
					additionalProperties: false,
				},
				{
					type: "object",
					required: ["account_id"],
					properties: {
						account_id: {
							description:
								'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
							type: "string",
						},
					},
					additionalProperties: false,
				},
			],
		},
		data: {
			type: "object",
			additionalProperties: { type: "string" },
			required: [],
		},
		version: { type: "string", enum: ["v1"] },
	},
	additionalProperties: false,
};

export const TonConnectPayloadSchemaTextSchema: JSONSchemaType<Types.TonConnectPayloadSchemaText> =
	{
		type: "object",
		required: ["text", "type"],
		properties: {
			text: { type: "string" },
			type: { type: "string", enum: ["text"] },
		},
		additionalProperties: false,
	};

export const Nep413DefusePayloadSchema: JSONSchemaType<Types.Nep413DefusePayload> =
	{
		type: "object",
		required: ["deadline", "signer_id"],
		properties: {
			deadline: { type: "string" },
			signer_id: {
				description:
					'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
				type: "string",
			},
			intents: {
				description:
					"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
				type: "array",
				items: {
					oneOf: [
						{
							description: "See [`AddPublicKey`]",
							type: "object",
							required: ["intent", "public_key"],
							properties: {
								intent: { type: "string", enum: ["add_public_key"] },
								public_key: {
									examples: [
										"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
										"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
									],
									type: "string",
									description: "Encoding: base58",
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`RemovePublicKey`]",
							type: "object",
							required: ["intent", "public_key"],
							properties: {
								intent: { type: "string", enum: ["remove_public_key"] },
								public_key: {
									examples: [
										"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
										"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
									],
									type: "string",
									description: "Encoding: base58",
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`Transfer`]",
							type: "object",
							required: ["intent", "receiver_id", "tokens"],
							properties: {
								intent: { type: "string", enum: ["transfer"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description: "Message to pass to `mt_on_transfer`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								state_init: {
									description:
										"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
									oneOf: [
										{
											type: "object",
											required: ["code", "data", "version"],
											properties: {
												code: {
													oneOf: [
														{
															type: "object",
															required: ["hash"],
															properties: { hash: { type: "string" } },
															additionalProperties: false,
														},
														{
															type: "object",
															required: ["account_id"],
															properties: {
																account_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
															},
															additionalProperties: false,
														},
													],
												},
												data: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												version: { type: "string", enum: ["v1"] },
											},
											additionalProperties: false,
										},
										{ type: "null" },
									],
								},
								tokens: {
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`FtWithdraw`]",
							type: "object",
							required: ["amount", "intent", "receiver_id", "token"],
							properties: {
								amount: { type: "string" },
								intent: { type: "string", enum: ["ft_withdraw"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description:
										"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								storage_deposit: {
									description:
										"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
									type: "string",
									nullable: true,
								},
								token: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`NftWithdraw`]",
							type: "object",
							required: ["intent", "receiver_id", "token", "token_id"],
							properties: {
								intent: { type: "string", enum: ["nft_withdraw"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description:
										"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								storage_deposit: {
									description:
										"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
									type: "string",
									nullable: true,
								},
								token: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								token_id: { type: "string" },
							},
							additionalProperties: false,
						},
						{
							description: "See [`MtWithdraw`]",
							type: "object",
							required: [
								"amounts",
								"intent",
								"receiver_id",
								"token",
								"token_ids",
							],
							properties: {
								amounts: { type: "array", items: { type: "string" } },
								intent: { type: "string", enum: ["mt_withdraw"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description:
										"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								storage_deposit: {
									description:
										"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
									type: "string",
									nullable: true,
								},
								token: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								token_ids: { type: "array", items: { type: "string" } },
							},
							additionalProperties: false,
						},
						{
							description: "See [`NativeWithdraw`]",
							type: "object",
							required: ["amount", "intent", "receiver_id"],
							properties: {
								amount: { type: "string" },
								intent: { type: "string", enum: ["native_withdraw"] },
								receiver_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`StorageDeposit`]",
							type: "object",
							required: [
								"amount",
								"contract_id",
								"deposit_for_account_id",
								"intent",
							],
							properties: {
								amount: { type: "string" },
								contract_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								deposit_for_account_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								intent: { type: "string", enum: ["storage_deposit"] },
							},
							additionalProperties: false,
						},
						{
							description: "See [`TokenDiff`]",
							type: "object",
							required: ["diff", "intent"],
							properties: {
								diff: {
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
								intent: { type: "string", enum: ["token_diff"] },
								memo: { type: "string", nullable: true },
								referral: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
									nullable: true,
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`SetAuthByPredecessorId`]",
							type: "object",
							required: ["enabled", "intent"],
							properties: {
								enabled: { type: "boolean" },
								intent: {
									type: "string",
									enum: ["set_auth_by_predecessor_id"],
								},
							},
							additionalProperties: false,
						},
						{
							description: "See [`AuthCall`]",
							type: "object",
							required: ["contract_id", "intent", "msg"],
							properties: {
								attached_deposit: {
									description:
										"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
									type: "string",
									nullable: true,
								},
								contract_id: {
									description:
										"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
									type: "string",
								},
								intent: { type: "string", enum: ["auth_call"] },
								min_gas: {
									description:
										"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description:
										"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
									type: "string",
								},
								state_init: {
									description:
										"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
									oneOf: [
										{
											type: "object",
											required: ["code", "data", "version"],
											properties: {
												code: {
													oneOf: [
														{
															type: "object",
															required: ["hash"],
															properties: { hash: { type: "string" } },
															additionalProperties: false,
														},
														{
															type: "object",
															required: ["account_id"],
															properties: {
																account_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
															},
															additionalProperties: false,
														},
													],
												},
												data: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												version: { type: "string", enum: ["v1"] },
											},
											additionalProperties: false,
										},
										{ type: "null" },
									],
								},
							},
							additionalProperties: false,
						},
						{
							description:
								"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
							type: "object",
							required: ["intent", "receiver_id", "tokens"],
							properties: {
								intent: { type: "string", enum: ["imt_mint"] },
								memo: { type: "string", nullable: true },
								min_gas: {
									description:
										"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
									type: "string",
									nullable: true,
								},
								msg: {
									description: "Message to pass to `mt_on_transfer`",
									type: "string",
									nullable: true,
								},
								receiver_id: {
									description: "Receiver of the minted tokens",
									type: "string",
								},
								state_init: {
									description:
										"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
									oneOf: [
										{
											type: "object",
											required: ["code", "data", "version"],
											properties: {
												code: {
													oneOf: [
														{
															type: "object",
															required: ["hash"],
															properties: { hash: { type: "string" } },
															additionalProperties: false,
														},
														{
															type: "object",
															required: ["account_id"],
															properties: {
																account_id: {
																	description:
																		'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																	type: "string",
																},
															},
															additionalProperties: false,
														},
													],
												},
												data: {
													type: "object",
													additionalProperties: { type: "string" },
													required: [],
												},
												version: { type: "string", enum: ["v1"] },
											},
											additionalProperties: false,
										},
										{ type: "null" },
									],
								},
								tokens: {
									description:
										"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
							},
							additionalProperties: false,
						},
						{
							description:
								"Burn a set of imt tokens, within the intents contract.",
							type: "object",
							required: ["intent", "minter_id", "tokens"],
							properties: {
								intent: { type: "string", enum: ["imt_burn"] },
								memo: { type: "string", nullable: true },
								minter_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								tokens: {
									description:
										"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
									type: "object",
									additionalProperties: { type: "string" },
									required: [],
								},
							},
							additionalProperties: false,
						},
					],
				},
				nullable: true,
			},
		},
		additionalProperties: false,
	};

// MultiPayloadNarrowedSchema is type-checked against the unparsed type, then exported as the Parsed type.
// This is correct because parseJson transforms string payloads into objects at runtime.
const _MultiPayloadNarrowedSchemaCheck: JSONSchemaType<Types.MultiPayloadNarrowed> =
	{
		oneOf: [
			{
				type: "object",
				required: ["standard", "payload"],
				additionalProperties: false,
				properties: {
					standard: { type: "string", enum: ["nep413"] },
					payload: {
						description:
							"See [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)",
						type: "object",
						required: ["message", "nonce", "recipient"],
						properties: {
							callbackUrl: { type: "string", nullable: true },
							message: {
								type: "string",
								parseJson: {
									type: "object",
									required: ["deadline", "signer_id"],
									properties: {
										deadline: { type: "string" },
										signer_id: {
											description:
												'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
											type: "string",
										},
										intents: {
											description:
												"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
											type: "array",
											items: {
												oneOf: [
													{
														description: "See [`AddPublicKey`]",
														type: "object",
														required: ["intent", "public_key"],
														properties: {
															intent: {
																type: "string",
																enum: ["add_public_key"],
															},
															public_key: {
																examples: [
																	"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
																	"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
																],
																type: "string",
																description: "Encoding: base58",
															},
														},
														additionalProperties: false,
													},
													{
														description: "See [`RemovePublicKey`]",
														type: "object",
														required: ["intent", "public_key"],
														properties: {
															intent: {
																type: "string",
																enum: ["remove_public_key"],
															},
															public_key: {
																examples: [
																	"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
																	"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
																],
																type: "string",
																description: "Encoding: base58",
															},
														},
														additionalProperties: false,
													},
													{
														description: "See [`Transfer`]",
														type: "object",
														required: ["intent", "receiver_id", "tokens"],
														properties: {
															intent: { type: "string", enum: ["transfer"] },
															memo: { type: "string", nullable: true },
															min_gas: {
																description:
																	"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																type: "string",
																nullable: true,
															},
															msg: {
																description:
																	"Message to pass to `mt_on_transfer`",
																type: "string",
																nullable: true,
															},
															receiver_id: {
																description:
																	'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																type: "string",
															},
															state_init: {
																description:
																	"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
																oneOf: [
																	{
																		type: "object",
																		required: ["code", "data", "version"],
																		properties: {
																			code: {
																				oneOf: [
																					{
																						type: "object",
																						required: ["hash"],
																						properties: {
																							hash: { type: "string" },
																						},
																						additionalProperties: false,
																					},
																					{
																						type: "object",
																						required: ["account_id"],
																						properties: {
																							account_id: {
																								description:
																									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																								type: "string",
																							},
																						},
																						additionalProperties: false,
																					},
																				],
																			},
																			data: {
																				type: "object",
																				additionalProperties: {
																					type: "string",
																				},
																				required: [],
																			},
																			version: { type: "string", enum: ["v1"] },
																		},
																		additionalProperties: false,
																	},
																	{ type: "null" },
																],
															},
															tokens: {
																type: "object",
																additionalProperties: { type: "string" },
																required: [],
															},
														},
														additionalProperties: false,
													},
													{
														description: "See [`FtWithdraw`]",
														type: "object",
														required: [
															"amount",
															"intent",
															"receiver_id",
															"token",
														],
														properties: {
															amount: { type: "string" },
															intent: { type: "string", enum: ["ft_withdraw"] },
															memo: { type: "string", nullable: true },
															min_gas: {
																description:
																	"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																type: "string",
																nullable: true,
															},
															msg: {
																description:
																	"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
																type: "string",
																nullable: true,
															},
															receiver_id: {
																description:
																	'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																type: "string",
															},
															storage_deposit: {
																description:
																	"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
																type: "string",
																nullable: true,
															},
															token: {
																description:
																	'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																type: "string",
															},
														},
														additionalProperties: false,
													},
													{
														description: "See [`NftWithdraw`]",
														type: "object",
														required: [
															"intent",
															"receiver_id",
															"token",
															"token_id",
														],
														properties: {
															intent: {
																type: "string",
																enum: ["nft_withdraw"],
															},
															memo: { type: "string", nullable: true },
															min_gas: {
																description:
																	"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																type: "string",
																nullable: true,
															},
															msg: {
																description:
																	"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
																type: "string",
																nullable: true,
															},
															receiver_id: {
																description:
																	'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																type: "string",
															},
															storage_deposit: {
																description:
																	"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
																type: "string",
																nullable: true,
															},
															token: {
																description:
																	'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																type: "string",
															},
															token_id: { type: "string" },
														},
														additionalProperties: false,
													},
													{
														description: "See [`MtWithdraw`]",
														type: "object",
														required: [
															"amounts",
															"intent",
															"receiver_id",
															"token",
															"token_ids",
														],
														properties: {
															amounts: {
																type: "array",
																items: { type: "string" },
															},
															intent: { type: "string", enum: ["mt_withdraw"] },
															memo: { type: "string", nullable: true },
															min_gas: {
																description:
																	"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																type: "string",
																nullable: true,
															},
															msg: {
																description:
																	"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
																type: "string",
																nullable: true,
															},
															receiver_id: {
																description:
																	'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																type: "string",
															},
															storage_deposit: {
																description:
																	"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
																type: "string",
																nullable: true,
															},
															token: {
																description:
																	'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																type: "string",
															},
															token_ids: {
																type: "array",
																items: { type: "string" },
															},
														},
														additionalProperties: false,
													},
													{
														description: "See [`NativeWithdraw`]",
														type: "object",
														required: ["amount", "intent", "receiver_id"],
														properties: {
															amount: { type: "string" },
															intent: {
																type: "string",
																enum: ["native_withdraw"],
															},
															receiver_id: {
																description:
																	'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																type: "string",
															},
														},
														additionalProperties: false,
													},
													{
														description: "See [`StorageDeposit`]",
														type: "object",
														required: [
															"amount",
															"contract_id",
															"deposit_for_account_id",
															"intent",
														],
														properties: {
															amount: { type: "string" },
															contract_id: {
																description:
																	'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																type: "string",
															},
															deposit_for_account_id: {
																description:
																	'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																type: "string",
															},
															intent: {
																type: "string",
																enum: ["storage_deposit"],
															},
														},
														additionalProperties: false,
													},
													{
														description: "See [`TokenDiff`]",
														type: "object",
														required: ["diff", "intent"],
														properties: {
															diff: {
																type: "object",
																additionalProperties: { type: "string" },
																required: [],
															},
															intent: { type: "string", enum: ["token_diff"] },
															memo: { type: "string", nullable: true },
															referral: {
																description:
																	'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																type: "string",
																nullable: true,
															},
														},
														additionalProperties: false,
													},
													{
														description: "See [`SetAuthByPredecessorId`]",
														type: "object",
														required: ["enabled", "intent"],
														properties: {
															enabled: { type: "boolean" },
															intent: {
																type: "string",
																enum: ["set_auth_by_predecessor_id"],
															},
														},
														additionalProperties: false,
													},
													{
														description: "See [`AuthCall`]",
														type: "object",
														required: ["contract_id", "intent", "msg"],
														properties: {
															attached_deposit: {
																description:
																	"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
																type: "string",
																nullable: true,
															},
															contract_id: {
																description:
																	"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
																type: "string",
															},
															intent: { type: "string", enum: ["auth_call"] },
															min_gas: {
																description:
																	"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																type: "string",
																nullable: true,
															},
															msg: {
																description:
																	"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
																type: "string",
															},
															state_init: {
																description:
																	"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
																oneOf: [
																	{
																		type: "object",
																		required: ["code", "data", "version"],
																		properties: {
																			code: {
																				oneOf: [
																					{
																						type: "object",
																						required: ["hash"],
																						properties: {
																							hash: { type: "string" },
																						},
																						additionalProperties: false,
																					},
																					{
																						type: "object",
																						required: ["account_id"],
																						properties: {
																							account_id: {
																								description:
																									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																								type: "string",
																							},
																						},
																						additionalProperties: false,
																					},
																				],
																			},
																			data: {
																				type: "object",
																				additionalProperties: {
																					type: "string",
																				},
																				required: [],
																			},
																			version: { type: "string", enum: ["v1"] },
																		},
																		additionalProperties: false,
																	},
																	{ type: "null" },
																],
															},
														},
														additionalProperties: false,
													},
													{
														description:
															"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
														type: "object",
														required: ["intent", "receiver_id", "tokens"],
														properties: {
															intent: { type: "string", enum: ["imt_mint"] },
															memo: { type: "string", nullable: true },
															min_gas: {
																description:
																	"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																type: "string",
																nullable: true,
															},
															msg: {
																description:
																	"Message to pass to `mt_on_transfer`",
																type: "string",
																nullable: true,
															},
															receiver_id: {
																description: "Receiver of the minted tokens",
																type: "string",
															},
															state_init: {
																description:
																	"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
																oneOf: [
																	{
																		type: "object",
																		required: ["code", "data", "version"],
																		properties: {
																			code: {
																				oneOf: [
																					{
																						type: "object",
																						required: ["hash"],
																						properties: {
																							hash: { type: "string" },
																						},
																						additionalProperties: false,
																					},
																					{
																						type: "object",
																						required: ["account_id"],
																						properties: {
																							account_id: {
																								description:
																									'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																								type: "string",
																							},
																						},
																						additionalProperties: false,
																					},
																				],
																			},
																			data: {
																				type: "object",
																				additionalProperties: {
																					type: "string",
																				},
																				required: [],
																			},
																			version: { type: "string", enum: ["v1"] },
																		},
																		additionalProperties: false,
																	},
																	{ type: "null" },
																],
															},
															tokens: {
																description:
																	"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
																type: "object",
																additionalProperties: { type: "string" },
																required: [],
															},
														},
														additionalProperties: false,
													},
													{
														description:
															"Burn a set of imt tokens, within the intents contract.",
														type: "object",
														required: ["intent", "minter_id", "tokens"],
														properties: {
															intent: { type: "string", enum: ["imt_burn"] },
															memo: { type: "string", nullable: true },
															minter_id: {
																description:
																	'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																type: "string",
															},
															tokens: {
																description:
																	"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
																type: "object",
																additionalProperties: { type: "string" },
																required: [],
															},
														},
														additionalProperties: false,
													},
												],
											},
											nullable: true,
										},
									},
									additionalProperties: false,
								},
							},
							nonce: { type: "string", description: "Encoding: base64" },
							recipient: { type: "string" },
						},
						additionalProperties: false,
					},
				},
			},
			{
				type: "object",
				required: ["standard", "payload"],
				additionalProperties: false,
				properties: {
					standard: { type: "string", enum: ["erc191"] },
					payload: {
						description:
							"See [ERC-191](https://github.com/ethereum/ercs/blob/master/ERCS/erc-191.md)",
						type: "string",
						parseJson: {
							type: "object",
							required: [
								"deadline",
								"nonce",
								"signer_id",
								"verifying_contract",
							],
							properties: {
								deadline: { type: "string" },
								intents: {
									description:
										"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
									type: "array",
									items: {
										oneOf: [
											{
												description: "See [`AddPublicKey`]",
												type: "object",
												required: ["intent", "public_key"],
												properties: {
													intent: { type: "string", enum: ["add_public_key"] },
													public_key: {
														examples: [
															"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
															"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
														],
														type: "string",
														description: "Encoding: base58",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`RemovePublicKey`]",
												type: "object",
												required: ["intent", "public_key"],
												properties: {
													intent: {
														type: "string",
														enum: ["remove_public_key"],
													},
													public_key: {
														examples: [
															"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
															"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
														],
														type: "string",
														description: "Encoding: base58",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`Transfer`]",
												type: "object",
												required: ["intent", "receiver_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["transfer"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description: "Message to pass to `mt_on_transfer`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
													tokens: {
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`FtWithdraw`]",
												type: "object",
												required: ["amount", "intent", "receiver_id", "token"],
												properties: {
													amount: { type: "string" },
													intent: { type: "string", enum: ["ft_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`NftWithdraw`]",
												type: "object",
												required: [
													"intent",
													"receiver_id",
													"token",
													"token_id",
												],
												properties: {
													intent: { type: "string", enum: ["nft_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													token_id: { type: "string" },
												},
												additionalProperties: false,
											},
											{
												description: "See [`MtWithdraw`]",
												type: "object",
												required: [
													"amounts",
													"intent",
													"receiver_id",
													"token",
													"token_ids",
												],
												properties: {
													amounts: { type: "array", items: { type: "string" } },
													intent: { type: "string", enum: ["mt_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													token_ids: {
														type: "array",
														items: { type: "string" },
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`NativeWithdraw`]",
												type: "object",
												required: ["amount", "intent", "receiver_id"],
												properties: {
													amount: { type: "string" },
													intent: { type: "string", enum: ["native_withdraw"] },
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`StorageDeposit`]",
												type: "object",
												required: [
													"amount",
													"contract_id",
													"deposit_for_account_id",
													"intent",
												],
												properties: {
													amount: { type: "string" },
													contract_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													deposit_for_account_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													intent: { type: "string", enum: ["storage_deposit"] },
												},
												additionalProperties: false,
											},
											{
												description: "See [`TokenDiff`]",
												type: "object",
												required: ["diff", "intent"],
												properties: {
													diff: {
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
													intent: { type: "string", enum: ["token_diff"] },
													memo: { type: "string", nullable: true },
													referral: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
														nullable: true,
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`SetAuthByPredecessorId`]",
												type: "object",
												required: ["enabled", "intent"],
												properties: {
													enabled: { type: "boolean" },
													intent: {
														type: "string",
														enum: ["set_auth_by_predecessor_id"],
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`AuthCall`]",
												type: "object",
												required: ["contract_id", "intent", "msg"],
												properties: {
													attached_deposit: {
														description:
															"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
														type: "string",
														nullable: true,
													},
													contract_id: {
														description:
															"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
														type: "string",
													},
													intent: { type: "string", enum: ["auth_call"] },
													min_gas: {
														description:
															"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
												},
												additionalProperties: false,
											},
											{
												description:
													"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
												type: "object",
												required: ["intent", "receiver_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["imt_mint"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description: "Message to pass to `mt_on_transfer`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description: "Receiver of the minted tokens",
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
													tokens: {
														description:
															"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
											{
												description:
													"Burn a set of imt tokens, within the intents contract.",
												type: "object",
												required: ["intent", "minter_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["imt_burn"] },
													memo: { type: "string", nullable: true },
													minter_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													tokens: {
														description:
															"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
										],
									},
									nullable: true,
								},
								nonce: {
									examples: ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],
									type: "string",
									description: "Encoding: base64",
								},
								signer_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								verifying_contract: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
							},
							additionalProperties: false,
						},
					},
				},
			},
			{
				type: "object",
				required: ["standard", "payload"],
				additionalProperties: false,
				properties: {
					standard: { type: "string", enum: ["tip191"] },
					payload: {
						description:
							"See [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md)",
						type: "string",
						parseJson: {
							type: "object",
							required: [
								"deadline",
								"nonce",
								"signer_id",
								"verifying_contract",
							],
							properties: {
								deadline: { type: "string" },
								intents: {
									description:
										"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
									type: "array",
									items: {
										oneOf: [
											{
												description: "See [`AddPublicKey`]",
												type: "object",
												required: ["intent", "public_key"],
												properties: {
													intent: { type: "string", enum: ["add_public_key"] },
													public_key: {
														examples: [
															"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
															"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
														],
														type: "string",
														description: "Encoding: base58",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`RemovePublicKey`]",
												type: "object",
												required: ["intent", "public_key"],
												properties: {
													intent: {
														type: "string",
														enum: ["remove_public_key"],
													},
													public_key: {
														examples: [
															"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
															"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
														],
														type: "string",
														description: "Encoding: base58",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`Transfer`]",
												type: "object",
												required: ["intent", "receiver_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["transfer"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description: "Message to pass to `mt_on_transfer`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
													tokens: {
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`FtWithdraw`]",
												type: "object",
												required: ["amount", "intent", "receiver_id", "token"],
												properties: {
													amount: { type: "string" },
													intent: { type: "string", enum: ["ft_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`NftWithdraw`]",
												type: "object",
												required: [
													"intent",
													"receiver_id",
													"token",
													"token_id",
												],
												properties: {
													intent: { type: "string", enum: ["nft_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													token_id: { type: "string" },
												},
												additionalProperties: false,
											},
											{
												description: "See [`MtWithdraw`]",
												type: "object",
												required: [
													"amounts",
													"intent",
													"receiver_id",
													"token",
													"token_ids",
												],
												properties: {
													amounts: { type: "array", items: { type: "string" } },
													intent: { type: "string", enum: ["mt_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													token_ids: {
														type: "array",
														items: { type: "string" },
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`NativeWithdraw`]",
												type: "object",
												required: ["amount", "intent", "receiver_id"],
												properties: {
													amount: { type: "string" },
													intent: { type: "string", enum: ["native_withdraw"] },
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`StorageDeposit`]",
												type: "object",
												required: [
													"amount",
													"contract_id",
													"deposit_for_account_id",
													"intent",
												],
												properties: {
													amount: { type: "string" },
													contract_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													deposit_for_account_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													intent: { type: "string", enum: ["storage_deposit"] },
												},
												additionalProperties: false,
											},
											{
												description: "See [`TokenDiff`]",
												type: "object",
												required: ["diff", "intent"],
												properties: {
													diff: {
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
													intent: { type: "string", enum: ["token_diff"] },
													memo: { type: "string", nullable: true },
													referral: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
														nullable: true,
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`SetAuthByPredecessorId`]",
												type: "object",
												required: ["enabled", "intent"],
												properties: {
													enabled: { type: "boolean" },
													intent: {
														type: "string",
														enum: ["set_auth_by_predecessor_id"],
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`AuthCall`]",
												type: "object",
												required: ["contract_id", "intent", "msg"],
												properties: {
													attached_deposit: {
														description:
															"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
														type: "string",
														nullable: true,
													},
													contract_id: {
														description:
															"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
														type: "string",
													},
													intent: { type: "string", enum: ["auth_call"] },
													min_gas: {
														description:
															"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
												},
												additionalProperties: false,
											},
											{
												description:
													"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
												type: "object",
												required: ["intent", "receiver_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["imt_mint"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description: "Message to pass to `mt_on_transfer`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description: "Receiver of the minted tokens",
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
													tokens: {
														description:
															"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
											{
												description:
													"Burn a set of imt tokens, within the intents contract.",
												type: "object",
												required: ["intent", "minter_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["imt_burn"] },
													memo: { type: "string", nullable: true },
													minter_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													tokens: {
														description:
															"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
										],
									},
									nullable: true,
								},
								nonce: {
									examples: ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],
									type: "string",
									description: "Encoding: base64",
								},
								signer_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								verifying_contract: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
							},
							additionalProperties: false,
						},
					},
				},
			},
			{
				type: "object",
				required: ["standard", "payload"],
				additionalProperties: false,
				properties: {
					standard: { type: "string", enum: ["raw_ed25519"] },
					payload: {
						type: "string",
						parseJson: {
							type: "object",
							required: [
								"deadline",
								"nonce",
								"signer_id",
								"verifying_contract",
							],
							properties: {
								deadline: { type: "string" },
								intents: {
									description:
										"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
									type: "array",
									items: {
										oneOf: [
											{
												description: "See [`AddPublicKey`]",
												type: "object",
												required: ["intent", "public_key"],
												properties: {
													intent: { type: "string", enum: ["add_public_key"] },
													public_key: {
														examples: [
															"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
															"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
														],
														type: "string",
														description: "Encoding: base58",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`RemovePublicKey`]",
												type: "object",
												required: ["intent", "public_key"],
												properties: {
													intent: {
														type: "string",
														enum: ["remove_public_key"],
													},
													public_key: {
														examples: [
															"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
															"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
														],
														type: "string",
														description: "Encoding: base58",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`Transfer`]",
												type: "object",
												required: ["intent", "receiver_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["transfer"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description: "Message to pass to `mt_on_transfer`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
													tokens: {
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`FtWithdraw`]",
												type: "object",
												required: ["amount", "intent", "receiver_id", "token"],
												properties: {
													amount: { type: "string" },
													intent: { type: "string", enum: ["ft_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`NftWithdraw`]",
												type: "object",
												required: [
													"intent",
													"receiver_id",
													"token",
													"token_id",
												],
												properties: {
													intent: { type: "string", enum: ["nft_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													token_id: { type: "string" },
												},
												additionalProperties: false,
											},
											{
												description: "See [`MtWithdraw`]",
												type: "object",
												required: [
													"amounts",
													"intent",
													"receiver_id",
													"token",
													"token_ids",
												],
												properties: {
													amounts: { type: "array", items: { type: "string" } },
													intent: { type: "string", enum: ["mt_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													token_ids: {
														type: "array",
														items: { type: "string" },
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`NativeWithdraw`]",
												type: "object",
												required: ["amount", "intent", "receiver_id"],
												properties: {
													amount: { type: "string" },
													intent: { type: "string", enum: ["native_withdraw"] },
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`StorageDeposit`]",
												type: "object",
												required: [
													"amount",
													"contract_id",
													"deposit_for_account_id",
													"intent",
												],
												properties: {
													amount: { type: "string" },
													contract_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													deposit_for_account_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													intent: { type: "string", enum: ["storage_deposit"] },
												},
												additionalProperties: false,
											},
											{
												description: "See [`TokenDiff`]",
												type: "object",
												required: ["diff", "intent"],
												properties: {
													diff: {
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
													intent: { type: "string", enum: ["token_diff"] },
													memo: { type: "string", nullable: true },
													referral: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
														nullable: true,
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`SetAuthByPredecessorId`]",
												type: "object",
												required: ["enabled", "intent"],
												properties: {
													enabled: { type: "boolean" },
													intent: {
														type: "string",
														enum: ["set_auth_by_predecessor_id"],
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`AuthCall`]",
												type: "object",
												required: ["contract_id", "intent", "msg"],
												properties: {
													attached_deposit: {
														description:
															"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
														type: "string",
														nullable: true,
													},
													contract_id: {
														description:
															"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
														type: "string",
													},
													intent: { type: "string", enum: ["auth_call"] },
													min_gas: {
														description:
															"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
												},
												additionalProperties: false,
											},
											{
												description:
													"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
												type: "object",
												required: ["intent", "receiver_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["imt_mint"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description: "Message to pass to `mt_on_transfer`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description: "Receiver of the minted tokens",
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
													tokens: {
														description:
															"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
											{
												description:
													"Burn a set of imt tokens, within the intents contract.",
												type: "object",
												required: ["intent", "minter_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["imt_burn"] },
													memo: { type: "string", nullable: true },
													minter_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													tokens: {
														description:
															"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
										],
									},
									nullable: true,
								},
								nonce: {
									examples: ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],
									type: "string",
									description: "Encoding: base64",
								},
								signer_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								verifying_contract: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
							},
							additionalProperties: false,
						},
					},
				},
			},
			{
				type: "object",
				required: ["standard", "payload"],
				additionalProperties: false,
				properties: {
					standard: { type: "string", enum: ["webauthn"] },
					payload: {
						type: "string",
						parseJson: {
							type: "object",
							required: [
								"deadline",
								"nonce",
								"signer_id",
								"verifying_contract",
							],
							properties: {
								deadline: { type: "string" },
								intents: {
									description:
										"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
									type: "array",
									items: {
										oneOf: [
											{
												description: "See [`AddPublicKey`]",
												type: "object",
												required: ["intent", "public_key"],
												properties: {
													intent: { type: "string", enum: ["add_public_key"] },
													public_key: {
														examples: [
															"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
															"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
														],
														type: "string",
														description: "Encoding: base58",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`RemovePublicKey`]",
												type: "object",
												required: ["intent", "public_key"],
												properties: {
													intent: {
														type: "string",
														enum: ["remove_public_key"],
													},
													public_key: {
														examples: [
															"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
															"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
														],
														type: "string",
														description: "Encoding: base58",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`Transfer`]",
												type: "object",
												required: ["intent", "receiver_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["transfer"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description: "Message to pass to `mt_on_transfer`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
													tokens: {
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`FtWithdraw`]",
												type: "object",
												required: ["amount", "intent", "receiver_id", "token"],
												properties: {
													amount: { type: "string" },
													intent: { type: "string", enum: ["ft_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`NftWithdraw`]",
												type: "object",
												required: [
													"intent",
													"receiver_id",
													"token",
													"token_id",
												],
												properties: {
													intent: { type: "string", enum: ["nft_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													token_id: { type: "string" },
												},
												additionalProperties: false,
											},
											{
												description: "See [`MtWithdraw`]",
												type: "object",
												required: [
													"amounts",
													"intent",
													"receiver_id",
													"token",
													"token_ids",
												],
												properties: {
													amounts: { type: "array", items: { type: "string" } },
													intent: { type: "string", enum: ["mt_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													token_ids: {
														type: "array",
														items: { type: "string" },
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`NativeWithdraw`]",
												type: "object",
												required: ["amount", "intent", "receiver_id"],
												properties: {
													amount: { type: "string" },
													intent: { type: "string", enum: ["native_withdraw"] },
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`StorageDeposit`]",
												type: "object",
												required: [
													"amount",
													"contract_id",
													"deposit_for_account_id",
													"intent",
												],
												properties: {
													amount: { type: "string" },
													contract_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													deposit_for_account_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													intent: { type: "string", enum: ["storage_deposit"] },
												},
												additionalProperties: false,
											},
											{
												description: "See [`TokenDiff`]",
												type: "object",
												required: ["diff", "intent"],
												properties: {
													diff: {
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
													intent: { type: "string", enum: ["token_diff"] },
													memo: { type: "string", nullable: true },
													referral: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
														nullable: true,
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`SetAuthByPredecessorId`]",
												type: "object",
												required: ["enabled", "intent"],
												properties: {
													enabled: { type: "boolean" },
													intent: {
														type: "string",
														enum: ["set_auth_by_predecessor_id"],
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`AuthCall`]",
												type: "object",
												required: ["contract_id", "intent", "msg"],
												properties: {
													attached_deposit: {
														description:
															"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
														type: "string",
														nullable: true,
													},
													contract_id: {
														description:
															"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
														type: "string",
													},
													intent: { type: "string", enum: ["auth_call"] },
													min_gas: {
														description:
															"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
												},
												additionalProperties: false,
											},
											{
												description:
													"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
												type: "object",
												required: ["intent", "receiver_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["imt_mint"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description: "Message to pass to `mt_on_transfer`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description: "Receiver of the minted tokens",
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
													tokens: {
														description:
															"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
											{
												description:
													"Burn a set of imt tokens, within the intents contract.",
												type: "object",
												required: ["intent", "minter_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["imt_burn"] },
													memo: { type: "string", nullable: true },
													minter_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													tokens: {
														description:
															"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
										],
									},
									nullable: true,
								},
								nonce: {
									examples: ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],
									type: "string",
									description: "Encoding: base64",
								},
								signer_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								verifying_contract: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
							},
							additionalProperties: false,
						},
					},
				},
			},
			{
				type: "object",
				required: ["standard", "payload"],
				additionalProperties: false,
				properties: {
					standard: { type: "string", enum: ["webauthn"] },
					payload: {
						type: "string",
						parseJson: {
							type: "object",
							required: [
								"deadline",
								"nonce",
								"signer_id",
								"verifying_contract",
							],
							properties: {
								deadline: { type: "string" },
								intents: {
									description:
										"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
									type: "array",
									items: {
										oneOf: [
											{
												description: "See [`AddPublicKey`]",
												type: "object",
												required: ["intent", "public_key"],
												properties: {
													intent: { type: "string", enum: ["add_public_key"] },
													public_key: {
														examples: [
															"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
															"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
														],
														type: "string",
														description: "Encoding: base58",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`RemovePublicKey`]",
												type: "object",
												required: ["intent", "public_key"],
												properties: {
													intent: {
														type: "string",
														enum: ["remove_public_key"],
													},
													public_key: {
														examples: [
															"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
															"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
														],
														type: "string",
														description: "Encoding: base58",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`Transfer`]",
												type: "object",
												required: ["intent", "receiver_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["transfer"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description: "Message to pass to `mt_on_transfer`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
													tokens: {
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`FtWithdraw`]",
												type: "object",
												required: ["amount", "intent", "receiver_id", "token"],
												properties: {
													amount: { type: "string" },
													intent: { type: "string", enum: ["ft_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`NftWithdraw`]",
												type: "object",
												required: [
													"intent",
													"receiver_id",
													"token",
													"token_id",
												],
												properties: {
													intent: { type: "string", enum: ["nft_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													token_id: { type: "string" },
												},
												additionalProperties: false,
											},
											{
												description: "See [`MtWithdraw`]",
												type: "object",
												required: [
													"amounts",
													"intent",
													"receiver_id",
													"token",
													"token_ids",
												],
												properties: {
													amounts: { type: "array", items: { type: "string" } },
													intent: { type: "string", enum: ["mt_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													token_ids: {
														type: "array",
														items: { type: "string" },
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`NativeWithdraw`]",
												type: "object",
												required: ["amount", "intent", "receiver_id"],
												properties: {
													amount: { type: "string" },
													intent: { type: "string", enum: ["native_withdraw"] },
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`StorageDeposit`]",
												type: "object",
												required: [
													"amount",
													"contract_id",
													"deposit_for_account_id",
													"intent",
												],
												properties: {
													amount: { type: "string" },
													contract_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													deposit_for_account_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													intent: { type: "string", enum: ["storage_deposit"] },
												},
												additionalProperties: false,
											},
											{
												description: "See [`TokenDiff`]",
												type: "object",
												required: ["diff", "intent"],
												properties: {
													diff: {
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
													intent: { type: "string", enum: ["token_diff"] },
													memo: { type: "string", nullable: true },
													referral: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
														nullable: true,
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`SetAuthByPredecessorId`]",
												type: "object",
												required: ["enabled", "intent"],
												properties: {
													enabled: { type: "boolean" },
													intent: {
														type: "string",
														enum: ["set_auth_by_predecessor_id"],
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`AuthCall`]",
												type: "object",
												required: ["contract_id", "intent", "msg"],
												properties: {
													attached_deposit: {
														description:
															"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
														type: "string",
														nullable: true,
													},
													contract_id: {
														description:
															"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
														type: "string",
													},
													intent: { type: "string", enum: ["auth_call"] },
													min_gas: {
														description:
															"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
												},
												additionalProperties: false,
											},
											{
												description:
													"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
												type: "object",
												required: ["intent", "receiver_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["imt_mint"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description: "Message to pass to `mt_on_transfer`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description: "Receiver of the minted tokens",
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
													tokens: {
														description:
															"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
											{
												description:
													"Burn a set of imt tokens, within the intents contract.",
												type: "object",
												required: ["intent", "minter_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["imt_burn"] },
													memo: { type: "string", nullable: true },
													minter_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													tokens: {
														description:
															"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
										],
									},
									nullable: true,
								},
								nonce: {
									examples: ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],
									type: "string",
									description: "Encoding: base64",
								},
								signer_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								verifying_contract: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
							},
							additionalProperties: false,
						},
					},
				},
			},
			{
				type: "object",
				required: ["standard", "payload"],
				additionalProperties: false,
				properties: {
					standard: { type: "string", enum: ["ton_connect"] },
					payload: {
						description:
							"See <https://docs.tonconsole.com/academy/sign-data#choosing-the-right-format>",
						oneOf: [
							{
								type: "object",
								required: ["text", "type"],
								properties: {
									text: {
										type: "string",
										parseJson: {
											type: "object",
											required: [
												"deadline",
												"nonce",
												"signer_id",
												"verifying_contract",
											],
											properties: {
												deadline: { type: "string" },
												intents: {
													description:
														"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
													type: "array",
													items: {
														oneOf: [
															{
																description: "See [`AddPublicKey`]",
																type: "object",
																required: ["intent", "public_key"],
																properties: {
																	intent: {
																		type: "string",
																		enum: ["add_public_key"],
																	},
																	public_key: {
																		examples: [
																			"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
																			"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
																		],
																		type: "string",
																		description: "Encoding: base58",
																	},
																},
																additionalProperties: false,
															},
															{
																description: "See [`RemovePublicKey`]",
																type: "object",
																required: ["intent", "public_key"],
																properties: {
																	intent: {
																		type: "string",
																		enum: ["remove_public_key"],
																	},
																	public_key: {
																		examples: [
																			"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
																			"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
																		],
																		type: "string",
																		description: "Encoding: base58",
																	},
																},
																additionalProperties: false,
															},
															{
																description: "See [`Transfer`]",
																type: "object",
																required: ["intent", "receiver_id", "tokens"],
																properties: {
																	intent: {
																		type: "string",
																		enum: ["transfer"],
																	},
																	memo: { type: "string", nullable: true },
																	min_gas: {
																		description:
																			"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																		type: "string",
																		nullable: true,
																	},
																	msg: {
																		description:
																			"Message to pass to `mt_on_transfer`",
																		type: "string",
																		nullable: true,
																	},
																	receiver_id: {
																		description:
																			'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																		type: "string",
																	},
																	state_init: {
																		description:
																			"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
																		oneOf: [
																			{
																				type: "object",
																				required: ["code", "data", "version"],
																				properties: {
																					code: {
																						oneOf: [
																							{
																								type: "object",
																								required: ["hash"],
																								properties: {
																									hash: { type: "string" },
																								},
																								additionalProperties: false,
																							},
																							{
																								type: "object",
																								required: ["account_id"],
																								properties: {
																									account_id: {
																										description:
																											'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																										type: "string",
																									},
																								},
																								additionalProperties: false,
																							},
																						],
																					},
																					data: {
																						type: "object",
																						additionalProperties: {
																							type: "string",
																						},
																						required: [],
																					},
																					version: {
																						type: "string",
																						enum: ["v1"],
																					},
																				},
																				additionalProperties: false,
																			},
																			{ type: "null" },
																		],
																	},
																	tokens: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																},
																additionalProperties: false,
															},
															{
																description: "See [`FtWithdraw`]",
																type: "object",
																required: [
																	"amount",
																	"intent",
																	"receiver_id",
																	"token",
																],
																properties: {
																	amount: { type: "string" },
																	intent: {
																		type: "string",
																		enum: ["ft_withdraw"],
																	},
																	memo: { type: "string", nullable: true },
																	min_gas: {
																		description:
																			"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																		type: "string",
																		nullable: true,
																	},
																	msg: {
																		description:
																			"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
																		type: "string",
																		nullable: true,
																	},
																	receiver_id: {
																		description:
																			'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																		type: "string",
																	},
																	storage_deposit: {
																		description:
																			"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
																		type: "string",
																		nullable: true,
																	},
																	token: {
																		description:
																			'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																		type: "string",
																	},
																},
																additionalProperties: false,
															},
															{
																description: "See [`NftWithdraw`]",
																type: "object",
																required: [
																	"intent",
																	"receiver_id",
																	"token",
																	"token_id",
																],
																properties: {
																	intent: {
																		type: "string",
																		enum: ["nft_withdraw"],
																	},
																	memo: { type: "string", nullable: true },
																	min_gas: {
																		description:
																			"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																		type: "string",
																		nullable: true,
																	},
																	msg: {
																		description:
																			"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
																		type: "string",
																		nullable: true,
																	},
																	receiver_id: {
																		description:
																			'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																		type: "string",
																	},
																	storage_deposit: {
																		description:
																			"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
																		type: "string",
																		nullable: true,
																	},
																	token: {
																		description:
																			'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																		type: "string",
																	},
																	token_id: { type: "string" },
																},
																additionalProperties: false,
															},
															{
																description: "See [`MtWithdraw`]",
																type: "object",
																required: [
																	"amounts",
																	"intent",
																	"receiver_id",
																	"token",
																	"token_ids",
																],
																properties: {
																	amounts: {
																		type: "array",
																		items: { type: "string" },
																	},
																	intent: {
																		type: "string",
																		enum: ["mt_withdraw"],
																	},
																	memo: { type: "string", nullable: true },
																	min_gas: {
																		description:
																			"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																		type: "string",
																		nullable: true,
																	},
																	msg: {
																		description:
																			"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
																		type: "string",
																		nullable: true,
																	},
																	receiver_id: {
																		description:
																			'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																		type: "string",
																	},
																	storage_deposit: {
																		description:
																			"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
																		type: "string",
																		nullable: true,
																	},
																	token: {
																		description:
																			'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																		type: "string",
																	},
																	token_ids: {
																		type: "array",
																		items: { type: "string" },
																	},
																},
																additionalProperties: false,
															},
															{
																description: "See [`NativeWithdraw`]",
																type: "object",
																required: ["amount", "intent", "receiver_id"],
																properties: {
																	amount: { type: "string" },
																	intent: {
																		type: "string",
																		enum: ["native_withdraw"],
																	},
																	receiver_id: {
																		description:
																			'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																		type: "string",
																	},
																},
																additionalProperties: false,
															},
															{
																description: "See [`StorageDeposit`]",
																type: "object",
																required: [
																	"amount",
																	"contract_id",
																	"deposit_for_account_id",
																	"intent",
																],
																properties: {
																	amount: { type: "string" },
																	contract_id: {
																		description:
																			'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																		type: "string",
																	},
																	deposit_for_account_id: {
																		description:
																			'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																		type: "string",
																	},
																	intent: {
																		type: "string",
																		enum: ["storage_deposit"],
																	},
																},
																additionalProperties: false,
															},
															{
																description: "See [`TokenDiff`]",
																type: "object",
																required: ["diff", "intent"],
																properties: {
																	diff: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	intent: {
																		type: "string",
																		enum: ["token_diff"],
																	},
																	memo: { type: "string", nullable: true },
																	referral: {
																		description:
																			'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																		type: "string",
																		nullable: true,
																	},
																},
																additionalProperties: false,
															},
															{
																description: "See [`SetAuthByPredecessorId`]",
																type: "object",
																required: ["enabled", "intent"],
																properties: {
																	enabled: { type: "boolean" },
																	intent: {
																		type: "string",
																		enum: ["set_auth_by_predecessor_id"],
																	},
																},
																additionalProperties: false,
															},
															{
																description: "See [`AuthCall`]",
																type: "object",
																required: ["contract_id", "intent", "msg"],
																properties: {
																	attached_deposit: {
																		description:
																			"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
																		type: "string",
																		nullable: true,
																	},
																	contract_id: {
																		description:
																			"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
																		type: "string",
																	},
																	intent: {
																		type: "string",
																		enum: ["auth_call"],
																	},
																	min_gas: {
																		description:
																			"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																		type: "string",
																		nullable: true,
																	},
																	msg: {
																		description:
																			"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
																		type: "string",
																	},
																	state_init: {
																		description:
																			"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
																		oneOf: [
																			{
																				type: "object",
																				required: ["code", "data", "version"],
																				properties: {
																					code: {
																						oneOf: [
																							{
																								type: "object",
																								required: ["hash"],
																								properties: {
																									hash: { type: "string" },
																								},
																								additionalProperties: false,
																							},
																							{
																								type: "object",
																								required: ["account_id"],
																								properties: {
																									account_id: {
																										description:
																											'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																										type: "string",
																									},
																								},
																								additionalProperties: false,
																							},
																						],
																					},
																					data: {
																						type: "object",
																						additionalProperties: {
																							type: "string",
																						},
																						required: [],
																					},
																					version: {
																						type: "string",
																						enum: ["v1"],
																					},
																				},
																				additionalProperties: false,
																			},
																			{ type: "null" },
																		],
																	},
																},
																additionalProperties: false,
															},
															{
																description:
																	"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
																type: "object",
																required: ["intent", "receiver_id", "tokens"],
																properties: {
																	intent: {
																		type: "string",
																		enum: ["imt_mint"],
																	},
																	memo: { type: "string", nullable: true },
																	min_gas: {
																		description:
																			"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
																		type: "string",
																		nullable: true,
																	},
																	msg: {
																		description:
																			"Message to pass to `mt_on_transfer`",
																		type: "string",
																		nullable: true,
																	},
																	receiver_id: {
																		description:
																			"Receiver of the minted tokens",
																		type: "string",
																	},
																	state_init: {
																		description:
																			"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
																		oneOf: [
																			{
																				type: "object",
																				required: ["code", "data", "version"],
																				properties: {
																					code: {
																						oneOf: [
																							{
																								type: "object",
																								required: ["hash"],
																								properties: {
																									hash: { type: "string" },
																								},
																								additionalProperties: false,
																							},
																							{
																								type: "object",
																								required: ["account_id"],
																								properties: {
																									account_id: {
																										description:
																											'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																										type: "string",
																									},
																								},
																								additionalProperties: false,
																							},
																						],
																					},
																					data: {
																						type: "object",
																						additionalProperties: {
																							type: "string",
																						},
																						required: [],
																					},
																					version: {
																						type: "string",
																						enum: ["v1"],
																					},
																				},
																				additionalProperties: false,
																			},
																			{ type: "null" },
																		],
																	},
																	tokens: {
																		description:
																			"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																},
																additionalProperties: false,
															},
															{
																description:
																	"Burn a set of imt tokens, within the intents contract.",
																type: "object",
																required: ["intent", "minter_id", "tokens"],
																properties: {
																	intent: {
																		type: "string",
																		enum: ["imt_burn"],
																	},
																	memo: { type: "string", nullable: true },
																	minter_id: {
																		description:
																			'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																		type: "string",
																	},
																	tokens: {
																		description:
																			"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																},
																additionalProperties: false,
															},
														],
													},
													nullable: true,
												},
												nonce: {
													examples: [
														"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
													],
													type: "string",
													description: "Encoding: base64",
												},
												signer_id: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
												verifying_contract: {
													description:
														'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
													type: "string",
												},
											},
											additionalProperties: false,
										},
									},
									type: { type: "string", enum: ["text"] },
								},
								additionalProperties: false,
							},
						],
					},
				},
			},
			{
				type: "object",
				required: ["standard", "payload"],
				additionalProperties: false,
				properties: {
					standard: { type: "string", enum: ["sep53"] },
					payload: {
						type: "string",
						parseJson: {
							type: "object",
							required: [
								"deadline",
								"nonce",
								"signer_id",
								"verifying_contract",
							],
							properties: {
								deadline: { type: "string" },
								intents: {
									description:
										"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure",
									type: "array",
									items: {
										oneOf: [
											{
												description: "See [`AddPublicKey`]",
												type: "object",
												required: ["intent", "public_key"],
												properties: {
													intent: { type: "string", enum: ["add_public_key"] },
													public_key: {
														examples: [
															"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
															"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
														],
														type: "string",
														description: "Encoding: base58",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`RemovePublicKey`]",
												type: "object",
												required: ["intent", "public_key"],
												properties: {
													intent: {
														type: "string",
														enum: ["remove_public_key"],
													},
													public_key: {
														examples: [
															"ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm",
															"secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3",
														],
														type: "string",
														description: "Encoding: base58",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`Transfer`]",
												type: "object",
												required: ["intent", "receiver_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["transfer"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description: "Message to pass to `mt_on_transfer`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
													tokens: {
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`FtWithdraw`]",
												type: "object",
												required: ["amount", "intent", "receiver_id", "token"],
												properties: {
													amount: { type: "string" },
													intent: { type: "string", enum: ["ft_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`NftWithdraw`]",
												type: "object",
												required: [
													"intent",
													"receiver_id",
													"token",
													"token_id",
												],
												properties: {
													intent: { type: "string", enum: ["nft_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													token_id: { type: "string" },
												},
												additionalProperties: false,
											},
											{
												description: "See [`MtWithdraw`]",
												type: "object",
												required: [
													"amounts",
													"intent",
													"receiver_id",
													"token",
													"token_ids",
												],
												properties: {
													amounts: { type: "array", items: { type: "string" } },
													intent: { type: "string", enum: ["mt_withdraw"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													storage_deposit: {
														description:
															"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail",
														type: "string",
														nullable: true,
													},
													token: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													token_ids: {
														type: "array",
														items: { type: "string" },
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`NativeWithdraw`]",
												type: "object",
												required: ["amount", "intent", "receiver_id"],
												properties: {
													amount: { type: "string" },
													intent: { type: "string", enum: ["native_withdraw"] },
													receiver_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`StorageDeposit`]",
												type: "object",
												required: [
													"amount",
													"contract_id",
													"deposit_for_account_id",
													"intent",
												],
												properties: {
													amount: { type: "string" },
													contract_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													deposit_for_account_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													intent: { type: "string", enum: ["storage_deposit"] },
												},
												additionalProperties: false,
											},
											{
												description: "See [`TokenDiff`]",
												type: "object",
												required: ["diff", "intent"],
												properties: {
													diff: {
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
													intent: { type: "string", enum: ["token_diff"] },
													memo: { type: "string", nullable: true },
													referral: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
														nullable: true,
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`SetAuthByPredecessorId`]",
												type: "object",
												required: ["enabled", "intent"],
												properties: {
													enabled: { type: "boolean" },
													intent: {
														type: "string",
														enum: ["set_auth_by_predecessor_id"],
													},
												},
												additionalProperties: false,
											},
											{
												description: "See [`AuthCall`]",
												type: "object",
												required: ["contract_id", "intent", "msg"],
												properties: {
													attached_deposit: {
														description:
															"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.\n\nNOTE: the `wNEAR` will not be refunded in case of fail.",
														type: "string",
														nullable: true,
													},
													contract_id: {
														description:
															"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
														type: "string",
													},
													intent: { type: "string", enum: ["auth_call"] },
													min_gas: {
														description:
															"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description:
															"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)",
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
												},
												additionalProperties: false,
											},
											{
												description:
													"Mint a set of tokens from the signer to a specified account id, within the intents contract.",
												type: "object",
												required: ["intent", "receiver_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["imt_mint"] },
													memo: { type: "string", nullable: true },
													min_gas: {
														description:
															"Minimum gas for `mt_on_transfer()`\n\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.",
														type: "string",
														nullable: true,
													},
													msg: {
														description: "Message to pass to `mt_on_transfer`",
														type: "string",
														nullable: true,
													},
													receiver_id: {
														description: "Receiver of the minted tokens",
														type: "string",
													},
													state_init: {
														description:
															"Optionally initialize the receiver's contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).",
														oneOf: [
															{
																type: "object",
																required: ["code", "data", "version"],
																properties: {
																	code: {
																		oneOf: [
																			{
																				type: "object",
																				required: ["hash"],
																				properties: {
																					hash: { type: "string" },
																				},
																				additionalProperties: false,
																			},
																			{
																				type: "object",
																				required: ["account_id"],
																				properties: {
																					account_id: {
																						description:
																							'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
																						type: "string",
																					},
																				},
																				additionalProperties: false,
																			},
																		],
																	},
																	data: {
																		type: "object",
																		additionalProperties: { type: "string" },
																		required: [],
																	},
																	version: { type: "string", enum: ["v1"] },
																},
																additionalProperties: false,
															},
															{ type: "null" },
														],
													},
													tokens: {
														description:
															"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
											{
												description:
													"Burn a set of imt tokens, within the intents contract.",
												type: "object",
												required: ["intent", "minter_id", "tokens"],
												properties: {
													intent: { type: "string", enum: ["imt_burn"] },
													memo: { type: "string", nullable: true },
													minter_id: {
														description:
															'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
														type: "string",
													},
													tokens: {
														description:
															"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`",
														type: "object",
														additionalProperties: { type: "string" },
														required: [],
													},
												},
												additionalProperties: false,
											},
										],
									},
									nullable: true,
								},
								nonce: {
									examples: ["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],
									type: "string",
									description: "Encoding: base64",
								},
								signer_id: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
								verifying_contract: {
									description:
										'NEAR Account Identifier.\n\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\n\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\n\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\n\n## Examples\n\n``` use near_account_id::AccountId;\n\nlet alice: AccountId = "alice.near".parse().unwrap();\n\nassert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```',
									type: "string",
								},
							},
							additionalProperties: false,
						},
					},
				},
			},
		],
	};
export const MultiPayloadNarrowedSchema =
	_MultiPayloadNarrowedSchemaCheck as unknown as JSONSchemaType<Types.MultiPayloadNarrowed__Parsed>;
