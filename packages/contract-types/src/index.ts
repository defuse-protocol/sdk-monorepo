/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * NEAR Account Identifier.
 *
 * This is a unique, syntactically valid, human-readable account identifier on the NEAR network.
 *
 * [See the crate-level docs for information about validation.](index.html#account-id-rules)
 *
 * Also see [Error kind precedence](AccountId#error-kind-precedence).
 *
 * ## Examples
 *
 * ``` use near_account_id::AccountId;
 *
 * let alice: AccountId = "alice.near".parse().unwrap();
 *
 * assert!("ƒelicia.near".parse::<AccountId>().is_err()); // (ƒ is not f) ```
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "AccountId".
 */
export type AccountId = string;
/**
 * Account identifier. This is the human readable UTF-8 string which is used internally to index accounts on the network and their respective state.
 *
 * This is the "referenced" version of the account ID. It is to [`AccountId`] what [`str`] is to [`String`], and works quite similarly to [`Path`]. Like with [`str`] and [`Path`], you can't have a value of type `AccountIdRef`, but you can have a reference like `&AccountIdRef` or `&mut AccountIdRef`.
 *
 * This type supports zero-copy deserialization offered by [`serde`](https://docs.rs/serde/), but cannot do the same for [`borsh`](https://docs.rs/borsh/) since the latter does not support zero-copy.
 *
 * # Examples ``` use near_account_id::{AccountId, AccountIdRef}; use std::convert::{TryFrom, TryInto};
 *
 * // Construction let alice = AccountIdRef::new("alice.near").unwrap(); assert!(AccountIdRef::new("invalid.").is_err()); ```
 *
 * [`FromStr`]: std::str::FromStr [`Path`]: std::path::Path
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "AccountIdRef".
 */
export type AccountIdRef = string;
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "Deadline".
 */
export type Deadline = string;
/**
 * 1 pip == 1/100th of bip == 0.0001%
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "Pips".
 */
export type Pips = number;
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "Intent".
 */
export type Intent =
	| IntentAddPublicKey
	| IntentRemovePublicKey
	| IntentTransfer
	| IntentFtWithdraw
	| IntentNftWithdraw
	| IntentMtWithdraw
	| IntentNativeWithdraw
	| IntentStorageDeposit
	| IntentTokenDiff
	| IntentSetAuthByPredecessorId
	| IntentAuthCall;
/**
 * See [ERC-191](https://github.com/ethereum/ercs/blob/master/ERCS/erc-191.md)
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "Erc191Payload".
 */
export type Erc191Payload = string;
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "InvariantViolated".
 */
export type InvariantViolated =
	| InvariantViolatedUnmatchedDeltas
	| InvariantViolatedOverflow;
/**
 * Assuming wallets want to interact with Intents protocol, besides preparing the data in a certain form, they have to have the capability to sign raw messages (off-chain signatures) using an algorithm we understand. This enum solves that problem.
 *
 * For example, because we support ERC-191 and know how to verify messages with that standard, we can allow wallets, like Metamask, sign messages to perform intents without having to support new cryptographic primitives and signing standards.
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "MultiPayload".
 */
export type MultiPayload =
	| MultiPayloadNep413
	| MultiPayloadErc191
	| MultiPayloadTip191
	| MultiPayloadRawEd25519
	| MultiPayloadWebauthn
	| MultiPayloadTonConnect
	| MultiPayloadSep53;
/**
 * See [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md)
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "Tip191Payload".
 */
export type Tip191Payload = string;
/**
 * See <https://docs.tonconsole.com/academy/sign-data#choosing-the-right-format>
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "TonConnectPayloadSchema".
 */
export type TonConnectPayloadSchema =
	| TonConnectPayloadSchemaText
	| TonConnectPayloadSchemaBinary
	| TonConnectPayloadSchemaCell;
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "PickFirst(DateTimeint64)".
 */
export type PickFirstDateTimeint64 = string | number;

export interface NEARIntentsContractABI {
	[k: string]: unknown;
}
/**
 * Call [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) with `signer_id` of intent.
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "AuthCall".
 */
export interface AuthCall {
	/**
	 * Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.
	 *
	 * NOTE: the `wNEAR` will not be refunded in case of fail.
	 */
	attached_deposit?: string;
	/**
	 * Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)
	 */
	contract_id: AccountId;
	/**
	 * Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.
	 *
	 * Remaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.
	 */
	min_gas?: string | null;
	/**
	 * `msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)
	 */
	msg: string;
}
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "DefuseConfig".
 */
export interface DefuseConfig {
	fees: FeesConfig;
	roles: RolesConfig;
	wnear_id: AccountId;
}
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "FeesConfig".
 */
export interface FeesConfig {
	fee: Pips;
	fee_collector: AccountId;
}
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "RolesConfig".
 */
export interface RolesConfig {
	admins: {
		[k: string]: AccountId[];
	};
	grantees: {
		[k: string]: AccountId[];
	};
	super_admins: AccountId[];
}
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "DefusePayload_for_DefuseIntents".
 */
export interface DefusePayloadFor_DefuseIntents {
	deadline: Deadline;
	/**
	 * Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure
	 */
	intents?: Intent[];
	nonce: string;
	signer_id: AccountId;
	verifying_contract: AccountId;
}
/**
 * See [`AddPublicKey`]
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "IntentAddPublicKey".
 */
export interface IntentAddPublicKey {
	intent: "add_public_key";
	public_key: string;
}
/**
 * See [`RemovePublicKey`]
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "IntentRemovePublicKey".
 */
export interface IntentRemovePublicKey {
	intent: "remove_public_key";
	public_key: string;
}
/**
 * See [`Transfer`]
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "IntentTransfer".
 */
export interface IntentTransfer {
	intent: "transfer";
	memo?: string | null;
	receiver_id: AccountId;
	tokens: {
		[k: string]: string;
	};
}
/**
 * See [`FtWithdraw`]
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "IntentFtWithdraw".
 */
export interface IntentFtWithdraw {
	amount: string;
	intent: "ft_withdraw";
	memo?: string | null;
	/**
	 * Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas
	 *
	 * Remaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.
	 */
	min_gas?: string | null;
	/**
	 * Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`
	 */
	msg?: string | null;
	receiver_id: AccountId;
	/**
	 * Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail
	 */
	storage_deposit?: string | null;
	token: AccountId;
}
/**
 * See [`NftWithdraw`]
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "IntentNftWithdraw".
 */
export interface IntentNftWithdraw {
	intent: "nft_withdraw";
	memo?: string | null;
	/**
	 * Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas
	 *
	 * Remaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.
	 */
	min_gas?: string | null;
	/**
	 * Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`
	 */
	msg?: string | null;
	receiver_id: AccountId;
	/**
	 * Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail
	 */
	storage_deposit?: string | null;
	token: AccountId;
	token_id: string;
}
/**
 * See [`MtWithdraw`]
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "IntentMtWithdraw".
 */
export interface IntentMtWithdraw {
	amounts: string[];
	intent: "mt_withdraw";
	memo?: string | null;
	/**
	 * Optional minimum required Near gas for created Promise to succeed: * `mt_batch_transfer`:      minimum: 15TGas, default: 15TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas
	 *
	 * Remaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.
	 */
	min_gas?: string | null;
	/**
	 * Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`
	 */
	msg?: string | null;
	receiver_id: AccountId;
	/**
	 * Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail
	 */
	storage_deposit?: string | null;
	token: AccountId;
	token_ids: string[];
}
/**
 * See [`NativeWithdraw`]
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "IntentNativeWithdraw".
 */
export interface IntentNativeWithdraw {
	amount: string;
	intent: "native_withdraw";
	receiver_id: AccountId;
}
/**
 * See [`StorageDeposit`]
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "IntentStorageDeposit".
 */
export interface IntentStorageDeposit {
	amount: string;
	contract_id: AccountId;
	deposit_for_account_id: AccountId;
	intent: "storage_deposit";
}
/**
 * See [`TokenDiff`]
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "IntentTokenDiff".
 */
export interface IntentTokenDiff {
	diff: {
		[k: string]: string;
	};
	intent: "token_diff";
	memo?: string | null;
	referral?: AccountId | null;
}
/**
 * See [`SetAuthByPredecessorId`]
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "IntentSetAuthByPredecessorId".
 */
export interface IntentSetAuthByPredecessorId {
	enabled: boolean;
	intent: "set_auth_by_predecessor_id";
}
/**
 * See [`AuthCall`]
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "IntentAuthCall".
 */
export interface IntentAuthCall {
	/**
	 * Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user's NEP-141 `wNEAR` balance.
	 *
	 * NOTE: the `wNEAR` will not be refunded in case of fail.
	 */
	attached_deposit?: string;
	/**
	 * Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)
	 */
	contract_id: AccountId;
	intent: "auth_call";
	/**
	 * Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.
	 *
	 * Remaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.
	 */
	min_gas?: string | null;
	/**
	 * `msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)
	 */
	msg: string;
}
/**
 * Withdraw given FT tokens from the intents contract to a given external account id (external being outside of intents).
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "FtWithdraw".
 */
export interface FtWithdraw {
	amount: string;
	memo?: string | null;
	/**
	 * Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas
	 *
	 * Remaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.
	 */
	min_gas?: string | null;
	/**
	 * Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`
	 */
	msg?: string | null;
	receiver_id: AccountId;
	/**
	 * Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail
	 */
	storage_deposit?: string | null;
	token: AccountId;
}
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "IntentEvent_for_AccountEvent_for_NonceEvent".
 */
export interface IntentEventFor_AccountEventFor_NonceEvent {
	account_id: AccountIdRef;
	intent_hash: string;
	nonce: string;
}
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "InvariantViolatedUnmatchedDeltas".
 */
export interface InvariantViolatedUnmatchedDeltas {
	error: "unmatched_deltas";
	unmatched_deltas: {
		[k: string]: string;
	};
}
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "InvariantViolatedOverflow".
 */
export interface InvariantViolatedOverflow {
	error: "overflow";
}
/**
 * Withdraw given MT tokens (i.e. [NEP-245](https://github.com/near/NEPs/blob/master/neps/nep-0245.md)) from the intents contract to a given to an external account id (external being outside of intents).
 *
 * If `msg` is given, `mt_batch_transfer_call()` will be used to transfer to the `receiver_id`. Otherwise, `mt_batch_transfer()` will be used.
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "MtWithdraw".
 */
export interface MtWithdraw {
	amounts: string[];
	memo?: string | null;
	/**
	 * Optional minimum required Near gas for created Promise to succeed: * `mt_batch_transfer`:      minimum: 15TGas, default: 15TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas
	 *
	 * Remaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.
	 */
	min_gas?: string | null;
	/**
	 * Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`
	 */
	msg?: string | null;
	receiver_id: AccountId;
	/**
	 * Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail
	 */
	storage_deposit?: string | null;
	token: AccountId;
	token_ids: string[];
}
/**
 * NEP-413: The standard for message signing in Near Protocol. For more details, refer to [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md).
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "MultiPayloadNep413".
 */
export interface MultiPayloadNep413 {
	payload: Nep413Payload;
	public_key: string;
	signature: string;
	standard: "nep413";
}
/**
 * See [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "Nep413Payload".
 */
export interface Nep413Payload {
	callbackUrl?: string | null;
	message: string;
	nonce: string;
	recipient: string;
}
/**
 * ERC-191: The standard for message signing in Ethereum, commonly used with `personal_sign()`. For more details, refer to [EIP-191](https://eips.ethereum.org/EIPS/eip-191).
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "MultiPayloadErc191".
 */
export interface MultiPayloadErc191 {
	payload: Erc191Payload;
	/**
	 * There is no public key member because the public key can be recovered via `ecrecover()` knowing the data and the signature
	 */
	signature: string;
	standard: "erc191";
}
/**
 * TIP-191: The standard for message signing in Tron. For more details, refer to [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md).
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "MultiPayloadTip191".
 */
export interface MultiPayloadTip191 {
	payload: Tip191Payload;
	/**
	 * There is no public key member because the public key can be recovered via `ecrecover()` knowing the data and the signature
	 */
	signature: string;
	standard: "tip191";
}
/**
 * Raw Ed25519: The standard used by Solana Phantom wallets for message signing. For more details, refer to [Phantom Wallet's documentation](https://docs.phantom.com/solana/signing-a-message).
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "MultiPayloadRawEd25519".
 */
export interface MultiPayloadRawEd25519 {
	payload: string;
	public_key: string;
	signature: string;
	standard: "raw_ed25519";
}
/**
 * [COSE ES256 (-7) algorithm](https://www.iana.org/assignments/cose/cose.xhtml#algorithms): NIST P-256 curve (a.k.a secp256r1) over SHA-256
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "MultiPayloadWebauthn".
 */
export interface MultiPayloadWebauthn {
	/**
	 * Base64Url-encoded [authenticatorData](https://w3c.github.io/webauthn/#authenticator-data)
	 */
	authenticator_data: string;
	/**
	 * Serialized [clientDataJSON](https://w3c.github.io/webauthn/#dom-authenticatorresponse-clientdatajson)
	 */
	client_data_json: string;
	payload: string;
	standard: "webauthn";
	public_key: string;
	signature: string;
}
/**
 * TonConnect: The standard for data signing in TON blockchain platform. For more details, refer to [TonConnect documentation](https://docs.tonconsole.com/academy/sign-data).
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "MultiPayloadTonConnect".
 */
export interface MultiPayloadTonConnect {
	/**
	 * Wallet address in either [Raw](https://docs.ton.org/v3/documentation/smart-contracts/addresses/address-formats#raw-address) representation or [user-friendly](https://docs.ton.org/v3/documentation/smart-contracts/addresses/address-formats#user-friendly-address) format
	 */
	address: string;
	/**
	 * dApp domain
	 */
	domain: string;
	payload: TonConnectPayloadSchema;
	public_key: string;
	signature: string;
	standard: "ton_connect";
	/**
	 * UNIX timestamp (in seconds or RFC3339) at the time of singing
	 */
	timestamp: PickFirstDateTimeint64;
}
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "TonConnectPayloadSchemaText".
 */
export interface TonConnectPayloadSchemaText {
	text: string;
	type: "text";
}
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "TonConnectPayloadSchemaBinary".
 */
export interface TonConnectPayloadSchemaBinary {
	bytes: string;
	type: "binary";
}
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "TonConnectPayloadSchemaCell".
 */
export interface TonConnectPayloadSchemaCell {
	cell: string;
	schema_crc: number;
	type: "cell";
}
/**
 * SEP-53: The standard for signing data off-chain for Stellar accounts. See [SEP-53](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0053.md)
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "MultiPayloadSep53".
 */
export interface MultiPayloadSep53 {
	payload: string;
	public_key: string;
	signature: string;
	standard: "sep53";
}
/**
 * Withdraw native tokens (NEAR) from the intents contract to a given external account id (external being outside of intents). This will subtract from the account's wNEAR balance, and will be sent to the account specified as native NEAR. NOTE: the `wNEAR` will not be refunded in case of fail (e.g. `receiver_id` account does not exist).
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "NativeWithdraw".
 */
export interface NativeWithdraw {
	amount: string;
	receiver_id: AccountId;
}
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "Nep413DefuseMessage_for_DefuseIntents".
 */
export interface Nep413DefuseMessageFor_DefuseIntents {
	deadline: Deadline;
	/**
	 * Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn't do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure
	 */
	intents?: Intent[];
	signer_id: AccountId;
}
/**
 * Withdraw given NFT tokens from the intents contract to a given external account id (external being outside of intents).
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "NftWithdraw".
 */
export interface NftWithdraw {
	memo?: string | null;
	/**
	 * Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas
	 *
	 * Remaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.
	 */
	min_gas?: string | null;
	/**
	 * Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`
	 */
	msg?: string | null;
	receiver_id: AccountId;
	/**
	 * Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail
	 */
	storage_deposit?: string | null;
	token: AccountId;
	token_id: string;
}
/**
 * Collects super admin accounts and accounts that have been granted permissions defined by `AccessControlRole`.
 *
 * # Data structure
 *
 * Assume `AccessControlRole` is derived for the following enum, which is then passed as `role` attribute to `AccessControllable`.
 *
 * ```rust pub enum Role { PauseManager, UnpauseManager, } ```
 *
 * Then the returned data has the following structure:
 *
 * ```ignore PermissionedAccounts { super_admins: vec!["acc1.near", "acc2.near"], roles: HashMap::from([ ("PauseManager", PermissionedAccountsPerRole { admins: vec!["acc3.near", "acc4.near"], grantees: vec!["acc5.near", "acc6.near"], }), ("UnpauseManager", PermissionedAccountsPerRole { admins: vec!["acc7.near", "acc8.near"], grantees: vec!["acc9.near", "acc10.near"], }), ]) } ```
 *
 * # Uniqueness and ordering
 *
 * Account ids returned in vectors are unique but not ordered.
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "PermissionedAccounts".
 */
export interface PermissionedAccounts {
	/**
	 * The admins and grantees of all roles.
	 */
	roles: {
		[k: string]: PermissionedAccountsPerRole;
	};
	/**
	 * The accounts that have super admin permissions.
	 */
	super_admins: AccountId[];
}
/**
 * Collects all admins and grantees of a role.
 *
 * # Uniqueness and ordering
 *
 * Account ids returned in vectors are unique but not ordered.
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "PermissionedAccountsPerRole".
 */
export interface PermissionedAccountsPerRole {
	/**
	 * The accounts that have admin permissions for the role.
	 */
	admins: AccountId[];
	/**
	 * The accounts that have been granted the role.
	 */
	grantees: AccountId[];
}
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "SimulationOutput".
 */
export interface SimulationOutput {
	intents_executed: IntentEventFor_AccountEventFor_NonceEvent[];
	/**
	 * Unmatched token deltas needed to keep the invariant. If not empty, can be used along with fee to calculate `token_diff` closure.
	 */
	invariant_violated?: InvariantViolated | null;
	logs: string[];
	min_deadline: Deadline;
	/**
	 * Additional info about current state
	 */
	state: StateOutput;
}
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "StateOutput".
 */
export interface StateOutput {
	current_salt: string;
	fee: Pips;
}
/**
 * Make [NEP-145](https://nomicon.io/Standards/StorageManagement#nep-145) `storage_deposit` for an `account_id` on `contract_id`. The `amount` will be subtracted from user's NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in any case.
 *
 * WARNING: use this intent only if paying storage_deposit is not a prerequisite for other intents to succeed. If some intent (e.g. ft_withdraw) requires storage_deposit, then use storage_deposit field of corresponding intent instead of adding a separate `StorageDeposit` intent. This is due to the fact that intents that fire `Promise`s are not guaranteed to be executed sequentially, in the order of the provided intents in `DefuseIntents`.
 *
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "StorageDeposit".
 */
export interface StorageDeposit {
	amount: string;
	contract_id: AccountId;
	deposit_for_account_id: AccountId;
}
/**
 * This interface was referenced by `NEARIntentsContractABI`'s JSON-Schema
 * via the `definition` "Token".
 */
export interface Token {
	owner_id?: AccountId | null;
	token_id: string;
}
