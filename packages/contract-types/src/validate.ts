/**
 * This file was automatically generated by gen-defuse-types.ts.
 * DO NOT MODIFY IT BY HAND.
 *
 * This file uses JSON.parse for fast schema loading (~1.5-2x faster than JS object literals).
 * For compile-time type checking, see type-check-schemas.ts (not included in bundle).
 */

import Ajv, { type JSONSchemaType } from "ajv";
import type { DataValidationCxt } from "ajv/dist/types";
import addFormats from "ajv-formats";
import type * as Types from "./index.js";
import { wrapValidator } from "./standard-schema.js";

// All schemas in a single JSON string for fast parsing
const schemas = JSON.parse(
	'{"AuthCall":{"description":"Call [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) with `signer_id` of intent.","type":"object","required":["contract_id","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},"Deadline":{"type":"string"},"DefuseConfig":{"type":"object","required":["fees","wnear_id"],"properties":{"fees":{"type":"object","required":["fee","fee_collector"],"properties":{"fee":{"description":"1 pip == 1/100th of bip == 0.0001%","type":"integer","format":"uint32","minimum":0},"fee_collector":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},"roles":{"default":{"admins":{},"grantees":{},"super_admins":[]},"type":"object","properties":{"admins":{"default":{},"type":"object","additionalProperties":{"type":"array","items":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"uniqueItems":true},"required":[]},"grantees":{"default":{},"type":"object","additionalProperties":{"type":"array","items":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"uniqueItems":true},"required":[]},"super_admins":{"default":[],"type":"array","items":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"uniqueItems":true}},"additionalProperties":false},"wnear_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},"DefusePayloadFor_DefuseIntents":{"type":"object","required":["deadline","nonce","signer_id","verifying_contract"],"properties":{"deadline":{"type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true},"nonce":{"examples":["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],"type":"string","description":"Encoding: base64"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"verifying_contract":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},"Erc191Payload":{"description":"See [ERC-191](https://github.com/ethereum/ercs/blob/master/ERCS/erc-191.md)","type":"string"},"FeesConfig":{"type":"object","required":["fee","fee_collector"],"properties":{"fee":{"description":"1 pip == 1/100th of bip == 0.0001%","type":"integer","format":"uint32","minimum":0},"fee_collector":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},"FtWithdraw":{"description":"Withdraw given FT tokens from the intents contract to a given external account id (external being outside of intents).","type":"object","required":["amount","receiver_id","token"],"properties":{"amount":{"type":"string"},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},"GlobalContractId":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"Intent":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"IntentEventFor_AccountEventFor_NonceEvent":{"type":"object","required":["account_id","intent_hash","nonce"],"properties":{"account_id":{"description":"Account identifier. This is the human readable UTF-8 string which is used internally to index accounts on the network and their respective state.\\n\\nThis is the \\"referenced\\" version of the account ID. It is to [`AccountId`] what [`str`] is to [`String`], and works quite similarly to [`Path`]. Like with [`str`] and [`Path`], you can\'t have a value of type `AccountIdRef`, but you can have a reference like `&AccountIdRef` or `&mut AccountIdRef`.\\n\\nThis type supports zero-copy deserialization offered by [`serde`](https://docs.rs/serde/), but cannot do the same for [`borsh`](https://docs.rs/borsh/) since the latter does not support zero-copy.\\n\\n# Examples ``` use near_account_id::{AccountId, AccountIdRef}; use std::convert::{TryFrom, TryInto};\\n\\n// Construction let alice = AccountIdRef::new(\\"alice.near\\").unwrap(); assert!(AccountIdRef::new(\\"invalid.\\").is_err()); ```\\n\\n[`FromStr`]: std::str::FromStr [`Path`]: std::path::Path","type":"string"},"intent_hash":{"type":"string","description":"Encoding: base58"},"nonce":{"type":"string","description":"Encoding: base64"}},"additionalProperties":false},"InvariantViolated":{"oneOf":[{"type":"object","required":["error","unmatched_deltas"],"properties":{"error":{"type":"string","enum":["unmatched_deltas"]},"unmatched_deltas":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"type":"object","required":["error"],"properties":{"error":{"type":"string","enum":["overflow"]}},"additionalProperties":false}]},"MtWithdraw":{"description":"Withdraw given MT tokens (i.e. [NEP-245](https://github.com/near/NEPs/blob/master/neps/nep-0245.md)) from the intents contract to a given to an external account id (external being outside of intents).\\n\\nIf `msg` is given, `mt_batch_transfer_call()` will be used to transfer to the `receiver_id`. Otherwise, `mt_batch_transfer()` will be used.","type":"object","required":["amounts","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},"MultiPayload":{"description":"Assuming wallets want to interact with Intents protocol, besides preparing the data in a certain form, they have to have the capability to sign raw messages (off-chain signatures) using an algorithm we understand. This enum solves that problem.\\n\\nFor example, because we support ERC-191 and know how to verify messages with that standard, we can allow wallets, like Metamask, sign messages to perform intents without having to support new cryptographic primitives and signing standards.","oneOf":[{"description":"NEP-413: The standard for message signing in Near Protocol. For more details, refer to [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md).","type":"object","required":["payload","public_key","signature","standard"],"properties":{"payload":{"description":"See [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)","type":"object","required":["message","nonce","recipient"],"properties":{"callbackUrl":{"type":"string","nullable":true},"message":{"type":"string","parseJson":{"type":"object","required":["deadline","signer_id"],"properties":{"deadline":{"type":"string"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true}},"additionalProperties":false}},"nonce":{"type":"string","description":"Encoding: base64"},"recipient":{"type":"string"}},"additionalProperties":false},"public_key":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"signature":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"standard":{"type":"string","enum":["nep413"]}},"additionalProperties":false},{"description":"ERC-191: The standard for message signing in Ethereum, commonly used with `personal_sign()`. For more details, refer to [EIP-191](https://eips.ethereum.org/EIPS/eip-191).","type":"object","required":["payload","signature","standard"],"properties":{"payload":{"description":"See [ERC-191](https://github.com/ethereum/ercs/blob/master/ERCS/erc-191.md)","type":"string","parseJson":{"type":"object","required":["deadline","nonce","signer_id","verifying_contract"],"properties":{"deadline":{"type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true},"nonce":{"examples":["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],"type":"string","description":"Encoding: base64"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"verifying_contract":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}},"signature":{"description":"There is no public key member because the public key can be recovered via `ecrecover()` knowing the data and the signature. Encoding: base58","type":"string","pattern":"^secp256k1:"},"standard":{"type":"string","enum":["erc191"]}},"additionalProperties":false},{"description":"TIP-191: The standard for message signing in Tron. For more details, refer to [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md).","type":"object","required":["payload","signature","standard"],"properties":{"payload":{"description":"See [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md)","type":"string","parseJson":{"type":"object","required":["deadline","nonce","signer_id","verifying_contract"],"properties":{"deadline":{"type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true},"nonce":{"examples":["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],"type":"string","description":"Encoding: base64"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"verifying_contract":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}},"signature":{"description":"There is no public key member because the public key can be recovered via `ecrecover()` knowing the data and the signature. Encoding: base58","type":"string","pattern":"^secp256k1:"},"standard":{"type":"string","enum":["tip191"]}},"additionalProperties":false},{"description":"Raw Ed25519: The standard used by Solana Phantom wallets for message signing. For more details, refer to [Phantom Wallet\'s documentation](https://docs.phantom.com/solana/signing-a-message).","type":"object","required":["payload","public_key","signature","standard"],"properties":{"payload":{"type":"string","parseJson":{"type":"object","required":["deadline","nonce","signer_id","verifying_contract"],"properties":{"deadline":{"type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true},"nonce":{"examples":["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],"type":"string","description":"Encoding: base64"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"verifying_contract":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}},"public_key":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"signature":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"standard":{"type":"string","enum":["raw_ed25519"]}},"additionalProperties":false},{"type":"object","required":["authenticator_data","client_data_json","payload","standard","public_key","signature"],"properties":{"authenticator_data":{"description":"Base64Url-encoded [authenticatorData](https://w3c.github.io/webauthn/#authenticator-data). Encoding: base64","type":"string"},"client_data_json":{"description":"Serialized [clientDataJSON](https://w3c.github.io/webauthn/#dom-authenticatorresponse-clientdatajson)","type":"string"},"payload":{"type":"string","parseJson":{"type":"object","required":["deadline","nonce","signer_id","verifying_contract"],"properties":{"deadline":{"type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true},"nonce":{"examples":["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],"type":"string","description":"Encoding: base64"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"verifying_contract":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}},"standard":{"type":"string","enum":["webauthn"]},"public_key":{"type":"string","pattern":"^(ed25519:|p256:)","description":"Encoding: base58"},"signature":{"type":"string","pattern":"^(ed25519:|p256:)","description":"Encoding: base58"}},"description":"[COSE EdDSA (-8) algorithm](https://www.iana.org/assignments/cose/cose.xhtml#algorithms): ed25519 curve","additionalProperties":false},{"description":"TonConnect: The standard for data signing in TON blockchain platform. For more details, refer to [TonConnect documentation](https://docs.tonconsole.com/academy/sign-data).","type":"object","required":["address","domain","payload","public_key","signature","standard","timestamp"],"properties":{"address":{"description":"Wallet address in either [Raw](https://docs.ton.org/v3/documentation/smart-contracts/addresses/address-formats#raw-address) representation or [user-friendly](https://docs.ton.org/v3/documentation/smart-contracts/addresses/address-formats#user-friendly-address) format","type":"string"},"domain":{"description":"dApp domain","type":"string"},"payload":{"description":"See <https://docs.tonconsole.com/academy/sign-data#choosing-the-right-format>","oneOf":[{"type":"object","required":["text","type"],"properties":{"text":{"type":"string","parseJson":{"type":"object","required":["deadline","nonce","signer_id","verifying_contract"],"properties":{"deadline":{"type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true},"nonce":{"examples":["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],"type":"string","description":"Encoding: base64"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"verifying_contract":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}},"type":{"type":"string","enum":["text"]}},"additionalProperties":false}]},"public_key":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"signature":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"standard":{"type":"string","enum":["ton_connect"]},"timestamp":{"description":"UNIX timestamp (in seconds or RFC3339) at the time of singing","anyOf":[{"type":"string","format":"date-time"},{"writeOnly":true,"type":"integer","format":"int64"}]}},"additionalProperties":false},{"description":"SEP-53: The standard for signing data off-chain for Stellar accounts. See [SEP-53](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0053.md)","type":"object","required":["payload","public_key","signature","standard"],"properties":{"payload":{"type":"string","parseJson":{"type":"object","required":["deadline","nonce","signer_id","verifying_contract"],"properties":{"deadline":{"type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true},"nonce":{"examples":["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],"type":"string","description":"Encoding: base64"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"verifying_contract":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}},"public_key":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"signature":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"standard":{"type":"string","enum":["sep53"]}},"additionalProperties":false}]},"NativeWithdraw":{"description":"Withdraw native tokens (NEAR) from the intents contract to a given external account id (external being outside of intents). This will subtract from the account\'s wNEAR balance, and will be sent to the account specified as native NEAR. NOTE: the `wNEAR` will not be refunded in case of fail (e.g. `receiver_id` account does not exist).","type":"object","required":["amount","receiver_id"],"properties":{"amount":{"type":"string"},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},"Nep413DefuseMessageFor_DefuseIntents":{"type":"object","required":["deadline","signer_id"],"properties":{"deadline":{"type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},"Nep413Payload":{"description":"See [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)","type":"object","required":["message","nonce","recipient"],"properties":{"callbackUrl":{"type":"string","nullable":true},"message":{"type":"string"},"nonce":{"type":"string","description":"Encoding: base64"},"recipient":{"type":"string"}},"additionalProperties":false},"NftWithdraw":{"description":"Withdraw given NFT tokens from the intents contract to a given external account id (external being outside of intents).","type":"object","required":["receiver_id","token","token_id"],"properties":{"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},"PermissionedAccounts":{"description":"Collects super admin accounts and accounts that have been granted permissions defined by `AccessControlRole`.\\n\\n# Data structure\\n\\nAssume `AccessControlRole` is derived for the following enum, which is then passed as `role` attribute to `AccessControllable`.\\n\\n```rust pub enum Role { PauseManager, UnpauseManager, } ```\\n\\nThen the returned data has the following structure:\\n\\n```ignore PermissionedAccounts { super_admins: vec![\\"acc1.near\\", \\"acc2.near\\"], roles: HashMap::from([ (\\"PauseManager\\", PermissionedAccountsPerRole { admins: vec![\\"acc3.near\\", \\"acc4.near\\"], grantees: vec![\\"acc5.near\\", \\"acc6.near\\"], }), (\\"UnpauseManager\\", PermissionedAccountsPerRole { admins: vec![\\"acc7.near\\", \\"acc8.near\\"], grantees: vec![\\"acc9.near\\", \\"acc10.near\\"], }), ]) } ```\\n\\n# Uniqueness and ordering\\n\\nAccount ids returned in vectors are unique but not ordered.","type":"object","required":["roles","super_admins"],"properties":{"roles":{"description":"The admins and grantees of all roles.","type":"object","additionalProperties":{"description":"Collects all admins and grantees of a role.\\n\\n# Uniqueness and ordering\\n\\nAccount ids returned in vectors are unique but not ordered.","type":"object","required":["admins","grantees"],"properties":{"admins":{"description":"The accounts that have admin permissions for the role.","type":"array","items":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"grantees":{"description":"The accounts that have been granted the role.","type":"array","items":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}}},"additionalProperties":false},"required":[]},"super_admins":{"description":"The accounts that have super admin permissions.","type":"array","items":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}}},"additionalProperties":false},"PermissionedAccountsPerRole":{"description":"Collects all admins and grantees of a role.\\n\\n# Uniqueness and ordering\\n\\nAccount ids returned in vectors are unique but not ordered.","type":"object","required":["admins","grantees"],"properties":{"admins":{"description":"The accounts that have admin permissions for the role.","type":"array","items":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"grantees":{"description":"The accounts that have been granted the role.","type":"array","items":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}}},"additionalProperties":false},"PickFirstDateTimeint64":{"anyOf":[{"type":"string","format":"date-time"},{"writeOnly":true,"type":"integer","format":"int64"}]},"Pips":{"description":"1 pip == 1/100th of bip == 0.0001%","type":"integer","format":"uint32","minimum":0},"RolesConfig":{"type":"object","properties":{"admins":{"default":{},"type":"object","additionalProperties":{"type":"array","items":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"uniqueItems":true},"required":[]},"grantees":{"default":{},"type":"object","additionalProperties":{"type":"array","items":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"uniqueItems":true},"required":[]},"super_admins":{"default":[],"type":"array","items":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"uniqueItems":true}},"additionalProperties":false},"SimulationOutput":{"type":"object","required":["intents_executed","logs","min_deadline","state"],"properties":{"intents_executed":{"type":"array","items":{"type":"object","required":["account_id","intent_hash","nonce"],"properties":{"account_id":{"description":"Account identifier. This is the human readable UTF-8 string which is used internally to index accounts on the network and their respective state.\\n\\nThis is the \\"referenced\\" version of the account ID. It is to [`AccountId`] what [`str`] is to [`String`], and works quite similarly to [`Path`]. Like with [`str`] and [`Path`], you can\'t have a value of type `AccountIdRef`, but you can have a reference like `&AccountIdRef` or `&mut AccountIdRef`.\\n\\nThis type supports zero-copy deserialization offered by [`serde`](https://docs.rs/serde/), but cannot do the same for [`borsh`](https://docs.rs/borsh/) since the latter does not support zero-copy.\\n\\n# Examples ``` use near_account_id::{AccountId, AccountIdRef}; use std::convert::{TryFrom, TryInto};\\n\\n// Construction let alice = AccountIdRef::new(\\"alice.near\\").unwrap(); assert!(AccountIdRef::new(\\"invalid.\\").is_err()); ```\\n\\n[`FromStr`]: std::str::FromStr [`Path`]: std::path::Path","type":"string"},"intent_hash":{"type":"string","description":"Encoding: base58"},"nonce":{"type":"string","description":"Encoding: base64"}},"additionalProperties":false}},"invariant_violated":{"description":"Unmatched token deltas needed to keep the invariant. If not empty, can be used along with fee to calculate `token_diff` closure.","oneOf":[{"type":"object","required":["error","unmatched_deltas"],"properties":{"error":{"type":"string","enum":["unmatched_deltas"]},"unmatched_deltas":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"type":"object","required":["error"],"properties":{"error":{"type":"string","enum":["overflow"]}},"additionalProperties":false},{"type":"null"}]},"logs":{"type":"array","items":{"type":"string"}},"min_deadline":{"type":"string"},"state":{"description":"Additional info about current state","type":"object","required":["current_salt","fee"],"properties":{"current_salt":{"type":"string","description":"Encoding: hex"},"fee":{"description":"1 pip == 1/100th of bip == 0.0001%","type":"integer","format":"uint32","minimum":0}},"additionalProperties":false}},"additionalProperties":false},"StateInit":{"oneOf":[{"type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false}]},"StateOutput":{"type":"object","required":["current_salt","fee"],"properties":{"current_salt":{"type":"string","description":"Encoding: hex"},"fee":{"description":"1 pip == 1/100th of bip == 0.0001%","type":"integer","format":"uint32","minimum":0}},"additionalProperties":false},"StorageDeposit":{"description":"Make [NEP-145](https://nomicon.io/Standards/StorageManagement#nep-145) `storage_deposit` for an `account_id` on `contract_id`. The `amount` will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in any case.\\n\\nWARNING: use this intent only if paying storage_deposit is not a prerequisite for other intents to succeed. If some intent (e.g. ft_withdraw) requires storage_deposit, then use storage_deposit field of corresponding intent instead of adding a separate `StorageDeposit` intent. This is due to the fact that intents that fire `Promise`s are not guaranteed to be executed sequentially, in the order of the provided intents in `DefuseIntents`.","type":"object","required":["amount","contract_id","deposit_for_account_id"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},"String":{"type":"string"},"Tip191Payload":{"description":"See [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md)","type":"string"},"Token":{"type":"object","required":["token_id"],"properties":{"owner_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true},"token_id":{"type":"string"}},"additionalProperties":false},"TonConnectPayloadSchema":{"description":"See <https://docs.tonconsole.com/academy/sign-data#choosing-the-right-format>","oneOf":[{"type":"object","required":["text","type"],"properties":{"text":{"type":"string"},"type":{"type":"string","enum":["text"]}},"additionalProperties":false}]},"IntentAddPublicKey":{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},"IntentRemovePublicKey":{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},"IntentTransfer":{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},"IntentFtWithdraw":{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},"IntentNftWithdraw":{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},"IntentMtWithdraw":{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},"IntentNativeWithdraw":{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},"IntentStorageDeposit":{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},"IntentTokenDiff":{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},"IntentSetAuthByPredecessorId":{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},"IntentAuthCall":{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},"IntentImtMint":{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},"IntentImtBurn":{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},"InvariantViolatedUnmatchedDeltas":{"type":"object","required":["error","unmatched_deltas"],"properties":{"error":{"type":"string","enum":["unmatched_deltas"]},"unmatched_deltas":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},"InvariantViolatedOverflow":{"type":"object","required":["error"],"properties":{"error":{"type":"string","enum":["overflow"]}},"additionalProperties":false},"MultiPayloadNep413":{"description":"NEP-413: The standard for message signing in Near Protocol. For more details, refer to [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md).","type":"object","required":["payload","public_key","signature","standard"],"properties":{"payload":{"description":"See [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)","type":"object","required":["message","nonce","recipient"],"properties":{"callbackUrl":{"type":"string","nullable":true},"message":{"type":"string"},"nonce":{"type":"string","description":"Encoding: base64"},"recipient":{"type":"string"}},"additionalProperties":false},"public_key":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"signature":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"standard":{"type":"string","enum":["nep413"]}},"additionalProperties":false},"MultiPayloadErc191":{"description":"ERC-191: The standard for message signing in Ethereum, commonly used with `personal_sign()`. For more details, refer to [EIP-191](https://eips.ethereum.org/EIPS/eip-191).","type":"object","required":["payload","signature","standard"],"properties":{"payload":{"description":"See [ERC-191](https://github.com/ethereum/ercs/blob/master/ERCS/erc-191.md)","type":"string"},"signature":{"description":"There is no public key member because the public key can be recovered via `ecrecover()` knowing the data and the signature. Encoding: base58","type":"string","pattern":"^secp256k1:"},"standard":{"type":"string","enum":["erc191"]}},"additionalProperties":false},"MultiPayloadTip191":{"description":"TIP-191: The standard for message signing in Tron. For more details, refer to [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md).","type":"object","required":["payload","signature","standard"],"properties":{"payload":{"description":"See [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md)","type":"string"},"signature":{"description":"There is no public key member because the public key can be recovered via `ecrecover()` knowing the data and the signature. Encoding: base58","type":"string","pattern":"^secp256k1:"},"standard":{"type":"string","enum":["tip191"]}},"additionalProperties":false},"MultiPayloadRawEd25519":{"description":"Raw Ed25519: The standard used by Solana Phantom wallets for message signing. For more details, refer to [Phantom Wallet\'s documentation](https://docs.phantom.com/solana/signing-a-message).","type":"object","required":["payload","public_key","signature","standard"],"properties":{"payload":{"type":"string"},"public_key":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"signature":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"standard":{"type":"string","enum":["raw_ed25519"]}},"additionalProperties":false},"MultiPayloadWebauthn":{"type":"object","required":["authenticator_data","client_data_json","payload","standard","public_key","signature"],"properties":{"authenticator_data":{"description":"Base64Url-encoded [authenticatorData](https://w3c.github.io/webauthn/#authenticator-data). Encoding: base64","type":"string"},"client_data_json":{"description":"Serialized [clientDataJSON](https://w3c.github.io/webauthn/#dom-authenticatorresponse-clientdatajson)","type":"string"},"payload":{"type":"string"},"standard":{"type":"string","enum":["webauthn"]},"public_key":{"type":"string","pattern":"^(ed25519:|p256:)","description":"Encoding: base58"},"signature":{"type":"string","pattern":"^(ed25519:|p256:)","description":"Encoding: base58"}},"description":"[COSE EdDSA (-8) algorithm](https://www.iana.org/assignments/cose/cose.xhtml#algorithms): ed25519 curve","additionalProperties":false},"MultiPayloadTonConnect":{"description":"TonConnect: The standard for data signing in TON blockchain platform. For more details, refer to [TonConnect documentation](https://docs.tonconsole.com/academy/sign-data).","type":"object","required":["address","domain","payload","public_key","signature","standard","timestamp"],"properties":{"address":{"description":"Wallet address in either [Raw](https://docs.ton.org/v3/documentation/smart-contracts/addresses/address-formats#raw-address) representation or [user-friendly](https://docs.ton.org/v3/documentation/smart-contracts/addresses/address-formats#user-friendly-address) format","type":"string"},"domain":{"description":"dApp domain","type":"string"},"payload":{"description":"See <https://docs.tonconsole.com/academy/sign-data#choosing-the-right-format>","oneOf":[{"type":"object","required":["text","type"],"properties":{"text":{"type":"string"},"type":{"type":"string","enum":["text"]}},"additionalProperties":false}]},"public_key":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"signature":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"standard":{"type":"string","enum":["ton_connect"]},"timestamp":{"description":"UNIX timestamp (in seconds or RFC3339) at the time of singing","anyOf":[{"type":"string","format":"date-time"},{"writeOnly":true,"type":"integer","format":"int64"}]}},"additionalProperties":false},"MultiPayloadSep53":{"description":"SEP-53: The standard for signing data off-chain for Stellar accounts. See [SEP-53](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0053.md)","type":"object","required":["payload","public_key","signature","standard"],"properties":{"payload":{"type":"string"},"public_key":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"signature":{"type":"string","pattern":"^ed25519:","description":"Encoding: base58"},"standard":{"type":"string","enum":["sep53"]}},"additionalProperties":false},"StateInitV1":{"type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false},"TonConnectPayloadSchemaText":{"type":"object","required":["text","type"],"properties":{"text":{"type":"string"},"type":{"type":"string","enum":["text"]}},"additionalProperties":false},"Nep413DefusePayload":{"type":"object","required":["deadline","signer_id"],"properties":{"deadline":{"type":"string"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true}},"additionalProperties":false},"MultiPayloadNarrowed":{"oneOf":[{"type":"object","required":["standard","payload"],"additionalProperties":false,"properties":{"standard":{"type":"string","enum":["nep413"]},"payload":{"description":"See [NEP-413](https://github.com/near/NEPs/blob/master/neps/nep-0413.md)","type":"object","required":["message","nonce","recipient"],"properties":{"callbackUrl":{"type":"string","nullable":true},"message":{"type":"string","parseJson":{"type":"object","required":["deadline","signer_id"],"properties":{"deadline":{"type":"string"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true}},"additionalProperties":false}},"nonce":{"type":"string","description":"Encoding: base64"},"recipient":{"type":"string"}},"additionalProperties":false}}},{"type":"object","required":["standard","payload"],"additionalProperties":false,"properties":{"standard":{"type":"string","enum":["erc191"]},"payload":{"description":"See [ERC-191](https://github.com/ethereum/ercs/blob/master/ERCS/erc-191.md)","type":"string","parseJson":{"type":"object","required":["deadline","nonce","signer_id","verifying_contract"],"properties":{"deadline":{"type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true},"nonce":{"examples":["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],"type":"string","description":"Encoding: base64"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"verifying_contract":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}}}},{"type":"object","required":["standard","payload"],"additionalProperties":false,"properties":{"standard":{"type":"string","enum":["tip191"]},"payload":{"description":"See [TIP-191](https://github.com/tronprotocol/tips/blob/master/tip-191.md)","type":"string","parseJson":{"type":"object","required":["deadline","nonce","signer_id","verifying_contract"],"properties":{"deadline":{"type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true},"nonce":{"examples":["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],"type":"string","description":"Encoding: base64"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"verifying_contract":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}}}},{"type":"object","required":["standard","payload"],"additionalProperties":false,"properties":{"standard":{"type":"string","enum":["raw_ed25519"]},"payload":{"type":"string","parseJson":{"type":"object","required":["deadline","nonce","signer_id","verifying_contract"],"properties":{"deadline":{"type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true},"nonce":{"examples":["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],"type":"string","description":"Encoding: base64"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"verifying_contract":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}}}},{"type":"object","required":["standard","payload"],"additionalProperties":false,"properties":{"standard":{"type":"string","enum":["webauthn"]},"payload":{"type":"string","parseJson":{"type":"object","required":["deadline","nonce","signer_id","verifying_contract"],"properties":{"deadline":{"type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true},"nonce":{"examples":["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],"type":"string","description":"Encoding: base64"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"verifying_contract":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}}}},{"type":"object","required":["standard","payload"],"additionalProperties":false,"properties":{"standard":{"type":"string","enum":["ton_connect"]},"payload":{"description":"See <https://docs.tonconsole.com/academy/sign-data#choosing-the-right-format>","oneOf":[{"type":"object","required":["text","type"],"properties":{"text":{"type":"string","parseJson":{"type":"object","required":["deadline","nonce","signer_id","verifying_contract"],"properties":{"deadline":{"type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true},"nonce":{"examples":["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],"type":"string","description":"Encoding: base64"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"verifying_contract":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}},"type":{"type":"string","enum":["text"]}},"additionalProperties":false}]}}},{"type":"object","required":["standard","payload"],"additionalProperties":false,"properties":{"standard":{"type":"string","enum":["sep53"]},"payload":{"type":"string","parseJson":{"type":"object","required":["deadline","nonce","signer_id","verifying_contract"],"properties":{"deadline":{"type":"string"},"intents":{"description":"Sequence of intents to execute in given order. Empty list is also a valid sequence, i.e. it doesn\'t do anything, but still invalidates the `nonce` for the signer WARNING: Promises created by different intents are executed concurrently and does not rely on the order of the intents in this structure","type":"array","items":{"oneOf":[{"description":"See [`AddPublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["add_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`RemovePublicKey`]","type":"object","required":["intent","public_key"],"properties":{"intent":{"type":"string","enum":["remove_public_key"]},"public_key":{"examples":["ed25519:5TagutioHgKLh7KZ1VEFBYfgRkPtqnKm9LoMnJMJugxm","secp256k1:3aMVMxsoAnHUbweXMtdKaN1uJaNwsfKv7wnc97SDGjXhyK62VyJwhPUPLZefKVthcoUcuWK6cqkSU4M542ipNxS3"],"type":"string","description":"Encoding: base58"}},"additionalProperties":false},{"description":"See [`Transfer`]","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["transfer"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"See [`FtWithdraw`]","type":"object","required":["amount","intent","receiver_id","token"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["ft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `ft_transfer`:      minimum: 15TGas, default: 15TGas * `ft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `ft_transfer_call`. Otherwise, `ft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`NftWithdraw`]","type":"object","required":["intent","receiver_id","token","token_id"],"properties":{"intent":{"type":"string","enum":["nft_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed: * `nft_transfer`:      minimum: 15TGas, default: 15TGas * `nft_transfer_call`: minimum: 30TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `nft_transfer_call`. Otherwise, `nft_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_id":{"type":"string"}},"additionalProperties":false},{"description":"See [`MtWithdraw`]","type":"object","required":["amounts","intent","receiver_id","token","token_ids"],"properties":{"amounts":{"type":"array","items":{"type":"string"}},"intent":{"type":"string","enum":["mt_withdraw"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Optional minimum required Near gas for created Promise to succeed per token: * `mt_batch_transfer`:      minimum: 20TGas, default: 20TGas * `mt_batch_transfer_call`: minimum: 35TGas, default: 50TGas\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_batch_transfer_call`. Otherwise, `mt_batch_transfer` will be used. NOTE: No refund will be made in case of insufficient `storage_deposit` on `token` for `receiver_id`","type":"string","nullable":true},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"storage_deposit":{"description":"Optionally make `storage_deposit` for `receiver_id` on `token`. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance. NOTE: the `wNEAR` will not be refunded in case of fail","type":"string","nullable":true},"token":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"token_ids":{"type":"array","items":{"type":"string"}}},"additionalProperties":false},{"description":"See [`NativeWithdraw`]","type":"object","required":["amount","intent","receiver_id"],"properties":{"amount":{"type":"string"},"intent":{"type":"string","enum":["native_withdraw"]},"receiver_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false},{"description":"See [`StorageDeposit`]","type":"object","required":["amount","contract_id","deposit_for_account_id","intent"],"properties":{"amount":{"type":"string"},"contract_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"deposit_for_account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"intent":{"type":"string","enum":["storage_deposit"]}},"additionalProperties":false},{"description":"See [`TokenDiff`]","type":"object","required":["diff","intent"],"properties":{"diff":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"intent":{"type":"string","enum":["token_diff"]},"memo":{"type":"string","nullable":true},"referral":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string","nullable":true}},"additionalProperties":false},{"description":"See [`SetAuthByPredecessorId`]","type":"object","required":["enabled","intent"],"properties":{"enabled":{"type":"boolean"},"intent":{"type":"string","enum":["set_auth_by_predecessor_id"]}},"additionalProperties":false},{"description":"See [`AuthCall`]","type":"object","required":["contract_id","intent","msg"],"properties":{"attached_deposit":{"description":"Optionally, attach deposit to [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth) call. The amount will be subtracted from user\'s NEP-141 `wNEAR` balance.\\n\\nNOTE: the `wNEAR` will not be refunded in case of fail.","type":"string","nullable":true},"contract_id":{"description":"Callee for [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"intent":{"type":"string","enum":["auth_call"]},"min_gas":{"description":"Optional minimum gas required for created promise to succeed. By default, only [`MIN_GAS_DEFAULT`](AuthCall::MIN_GAS_DEFAULT) is required.\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"`msg` to pass in [`.on_auth`](::defuse_auth_call::AuthCallee::on_auth)","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling [`.on_auth()`](::defuse_auth_call::AuthCallee::on_auth) (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true}},"additionalProperties":false},{"description":"Mint a set of tokens from the signer to a specified account id, within the intents contract.","type":"object","required":["intent","receiver_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_mint"]},"memo":{"type":"string","nullable":true},"min_gas":{"description":"Minimum gas for `mt_on_transfer()`\\n\\nRemaining gas will be distributed evenly across all Function Call Promises created during execution of current receipt.","type":"string","nullable":true},"msg":{"description":"Message to pass to `mt_on_transfer`","type":"string","nullable":true},"receiver_id":{"description":"Receiver of the minted tokens","type":"string"},"state_init":{"description":"Optionally initialize the receiver\'s contract (Deterministic AccountId) via [`state_init`](https://github.com/near/NEPs/blob/master/neps/nep-0616.md#stateinit-action) right before calling `mt_on_transfer()` (in the same receipt).","type":"object","required":["code","data","version"],"properties":{"code":{"oneOf":[{"type":"object","required":["hash"],"properties":{"hash":{"type":"string"}},"additionalProperties":false},{"type":"object","required":["account_id"],"properties":{"account_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}]},"data":{"type":"object","additionalProperties":{"type":"string"},"required":[]},"version":{"type":"string","enum":["v1"]}},"additionalProperties":false,"nullable":true},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority (i.e. signer of this intent). The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false},{"description":"Burn a set of imt tokens, within the intents contract.","type":"object","required":["intent","minter_id","tokens"],"properties":{"intent":{"type":"string","enum":["imt_burn"]},"memo":{"type":"string","nullable":true},"minter_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"tokens":{"description":"The token_ids will be wrapped to bind the token ID to the minter authority. The final string representation of the token will be as follows: `imt:<minter_id>:<token_id>`","type":"object","additionalProperties":{"type":"string"},"required":[]}},"additionalProperties":false}]},"nullable":true},"nonce":{"examples":["AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="],"type":"string","description":"Encoding: base64"},"signer_id":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"},"verifying_contract":{"description":"NEAR Account Identifier.\\n\\nThis is a unique, syntactically valid, human-readable account identifier on the NEAR network.\\n\\n[See the crate-level docs for information about validation.](index.html#account-id-rules)\\n\\nAlso see [Error kind precedence](AccountId#error-kind-precedence).\\n\\n## Examples\\n\\n``` use near_account_id::AccountId;\\n\\nlet alice: AccountId = \\"alice.near\\".parse().unwrap();\\n\\nassert!(\\"ƒelicia.near\\".parse::<AccountId>().is_err()); // (ƒ is not f) ```","type":"string"}},"additionalProperties":false}}}}]}}',
);

const ajv = new Ajv({
	formats: {
		// Rust/schemars formats - ignore validation but allow in schema
		uint32: true,
		int64: true,
	},
});
addFormats(ajv);

// Mutating data in-place inside oneOf corrupts sibling branches:
// erc191 branch replaces payload string with {original, parsed} object,
// so tip191/sep53 branches see an object instead of a string and fail.
let activeMutations: Array<() => void> = [];

ajv.addKeyword({
	keyword: "parseJson",
	modifying: true,
	schema: true,
	validate: function validateParseJson(
		schema: Record<string, unknown>,
		data: unknown,
		_parentSchema: unknown,
		dataCtx?: DataValidationCxt,
	): boolean {
		if (typeof data !== "string" || !dataCtx) return true;

		try {
			const parsed: unknown = JSON.parse(data);
			const isValid = ajv.validate(schema, parsed);
			if (isValid) {
				const { parentData, parentDataProperty } = dataCtx;
				const original = data;
				activeMutations.push(() => {
					parentData[parentDataProperty] = { original, parsed };
				});
			}
			return isValid;
		} catch {
			return false;
		}
	},
});

function compileParseJson<T>(schema: Parameters<typeof ajv.compile>[0]) {
	const validate = ajv.compile<T>(schema);
	const wrapped = (data: unknown): data is T => {
		const mutations: Array<() => void> = [];
		activeMutations = mutations;
		const valid = validate(data) as boolean;
		if (valid) {
			for (const m of mutations) m();
		}
		wrapped.errors = validate.errors;
		return valid;
	};
	wrapped.errors = validate.errors;
	wrapped.schema = validate.schema;
	return wrapped as typeof validate;
}

export const AuthCallValidator = wrapValidator<Types.AuthCall, Types.AuthCall>(
	() => ajv.compile(schemas.AuthCall as JSONSchemaType<Types.AuthCall>),
);
export const DeadlineValidator = wrapValidator<Types.Deadline, Types.Deadline>(
	() => ajv.compile(schemas.Deadline as JSONSchemaType<Types.Deadline>),
);
export const DefuseConfigValidator = wrapValidator<
	Types.DefuseConfig,
	Types.DefuseConfig
>(() =>
	ajv.compile(schemas.DefuseConfig as JSONSchemaType<Types.DefuseConfig>),
);
export const DefusePayloadFor_DefuseIntentsValidator = wrapValidator<
	Types.DefusePayloadFor_DefuseIntents,
	Types.DefusePayloadFor_DefuseIntents
>(() =>
	ajv.compile(
		schemas.DefusePayloadFor_DefuseIntents as JSONSchemaType<Types.DefusePayloadFor_DefuseIntents>,
	),
);
export const Erc191PayloadValidator = wrapValidator<
	Types.Erc191Payload,
	Types.Erc191Payload
>(() =>
	ajv.compile(schemas.Erc191Payload as JSONSchemaType<Types.Erc191Payload>),
);
export const FeesConfigValidator = wrapValidator<
	Types.FeesConfig,
	Types.FeesConfig
>(() => ajv.compile(schemas.FeesConfig as JSONSchemaType<Types.FeesConfig>));
export const FtWithdrawValidator = wrapValidator<
	Types.FtWithdraw,
	Types.FtWithdraw
>(() => ajv.compile(schemas.FtWithdraw as JSONSchemaType<Types.FtWithdraw>));
export const GlobalContractIdValidator = wrapValidator<
	Types.GlobalContractId,
	Types.GlobalContractId
>(() =>
	ajv.compile(
		schemas.GlobalContractId as JSONSchemaType<Types.GlobalContractId>,
	),
);
export const IntentValidator = wrapValidator<Types.Intent, Types.Intent>(() =>
	ajv.compile(schemas.Intent as JSONSchemaType<Types.Intent>),
);
export const IntentEventFor_AccountEventFor_NonceEventValidator = wrapValidator<
	Types.IntentEventFor_AccountEventFor_NonceEvent,
	Types.IntentEventFor_AccountEventFor_NonceEvent
>(() =>
	ajv.compile(
		schemas.IntentEventFor_AccountEventFor_NonceEvent as JSONSchemaType<Types.IntentEventFor_AccountEventFor_NonceEvent>,
	),
);
export const InvariantViolatedValidator = wrapValidator<
	Types.InvariantViolated,
	Types.InvariantViolated
>(() =>
	ajv.compile(
		schemas.InvariantViolated as JSONSchemaType<Types.InvariantViolated>,
	),
);
export const MtWithdrawValidator = wrapValidator<
	Types.MtWithdraw,
	Types.MtWithdraw
>(() => ajv.compile(schemas.MtWithdraw as JSONSchemaType<Types.MtWithdraw>));
export const MultiPayloadValidator = wrapValidator<
	Types.MultiPayload,
	Types.MultiPayload__Parsed
>(
	() =>
		compileParseJson<Types.MultiPayload__Parsed>(
			schemas.MultiPayload as JSONSchemaType<Types.MultiPayload__Parsed>,
		),
	true,
);
export const NativeWithdrawValidator = wrapValidator<
	Types.NativeWithdraw,
	Types.NativeWithdraw
>(() =>
	ajv.compile(schemas.NativeWithdraw as JSONSchemaType<Types.NativeWithdraw>),
);
export const Nep413DefuseMessageFor_DefuseIntentsValidator = wrapValidator<
	Types.Nep413DefuseMessageFor_DefuseIntents,
	Types.Nep413DefuseMessageFor_DefuseIntents
>(() =>
	ajv.compile(
		schemas.Nep413DefuseMessageFor_DefuseIntents as JSONSchemaType<Types.Nep413DefuseMessageFor_DefuseIntents>,
	),
);
export const Nep413PayloadValidator = wrapValidator<
	Types.Nep413Payload,
	Types.Nep413Payload
>(() =>
	ajv.compile(schemas.Nep413Payload as JSONSchemaType<Types.Nep413Payload>),
);
export const NftWithdrawValidator = wrapValidator<
	Types.NftWithdraw,
	Types.NftWithdraw
>(() => ajv.compile(schemas.NftWithdraw as JSONSchemaType<Types.NftWithdraw>));
export const PermissionedAccountsValidator = wrapValidator<
	Types.PermissionedAccounts,
	Types.PermissionedAccounts
>(() =>
	ajv.compile(
		schemas.PermissionedAccounts as JSONSchemaType<Types.PermissionedAccounts>,
	),
);
export const PermissionedAccountsPerRoleValidator = wrapValidator<
	Types.PermissionedAccountsPerRole,
	Types.PermissionedAccountsPerRole
>(() =>
	ajv.compile(
		schemas.PermissionedAccountsPerRole as JSONSchemaType<Types.PermissionedAccountsPerRole>,
	),
);
export const PickFirstDateTimeint64Validator = wrapValidator<
	Types.PickFirstDateTimeint64,
	Types.PickFirstDateTimeint64
>(() =>
	ajv.compile(
		schemas.PickFirstDateTimeint64 as JSONSchemaType<Types.PickFirstDateTimeint64>,
	),
);
export const PipsValidator = wrapValidator<Types.Pips, Types.Pips>(() =>
	ajv.compile(schemas.Pips as JSONSchemaType<Types.Pips>),
);
export const RolesConfigValidator = wrapValidator<
	Types.RolesConfig,
	Types.RolesConfig
>(() => ajv.compile(schemas.RolesConfig as JSONSchemaType<Types.RolesConfig>));
export const SimulationOutputValidator = wrapValidator<
	Types.SimulationOutput,
	Types.SimulationOutput
>(() =>
	ajv.compile(
		schemas.SimulationOutput as JSONSchemaType<Types.SimulationOutput>,
	),
);
export const StateInitValidator = wrapValidator<
	Types.StateInit,
	Types.StateInit
>(() => ajv.compile(schemas.StateInit as JSONSchemaType<Types.StateInit>));
export const StateOutputValidator = wrapValidator<
	Types.StateOutput,
	Types.StateOutput
>(() => ajv.compile(schemas.StateOutput as JSONSchemaType<Types.StateOutput>));
export const StorageDepositValidator = wrapValidator<
	Types.StorageDeposit,
	Types.StorageDeposit
>(() =>
	ajv.compile(schemas.StorageDeposit as JSONSchemaType<Types.StorageDeposit>),
);
export const StringValidator = wrapValidator<Types.String, Types.String>(() =>
	ajv.compile(schemas.String as JSONSchemaType<Types.String>),
);
export const Tip191PayloadValidator = wrapValidator<
	Types.Tip191Payload,
	Types.Tip191Payload
>(() =>
	ajv.compile(schemas.Tip191Payload as JSONSchemaType<Types.Tip191Payload>),
);
export const TokenValidator = wrapValidator<Types.Token, Types.Token>(() =>
	ajv.compile(schemas.Token as JSONSchemaType<Types.Token>),
);
export const TonConnectPayloadSchemaValidator = wrapValidator<
	Types.TonConnectPayloadSchema,
	Types.TonConnectPayloadSchema
>(() =>
	ajv.compile(
		schemas.TonConnectPayloadSchema as JSONSchemaType<Types.TonConnectPayloadSchema>,
	),
);
export const IntentAddPublicKeyValidator = wrapValidator<
	Types.IntentAddPublicKey,
	Types.IntentAddPublicKey
>(() =>
	ajv.compile(
		schemas.IntentAddPublicKey as JSONSchemaType<Types.IntentAddPublicKey>,
	),
);
export const IntentRemovePublicKeyValidator = wrapValidator<
	Types.IntentRemovePublicKey,
	Types.IntentRemovePublicKey
>(() =>
	ajv.compile(
		schemas.IntentRemovePublicKey as JSONSchemaType<Types.IntentRemovePublicKey>,
	),
);
export const IntentTransferValidator = wrapValidator<
	Types.IntentTransfer,
	Types.IntentTransfer
>(() =>
	ajv.compile(schemas.IntentTransfer as JSONSchemaType<Types.IntentTransfer>),
);
export const IntentFtWithdrawValidator = wrapValidator<
	Types.IntentFtWithdraw,
	Types.IntentFtWithdraw
>(() =>
	ajv.compile(
		schemas.IntentFtWithdraw as JSONSchemaType<Types.IntentFtWithdraw>,
	),
);
export const IntentNftWithdrawValidator = wrapValidator<
	Types.IntentNftWithdraw,
	Types.IntentNftWithdraw
>(() =>
	ajv.compile(
		schemas.IntentNftWithdraw as JSONSchemaType<Types.IntentNftWithdraw>,
	),
);
export const IntentMtWithdrawValidator = wrapValidator<
	Types.IntentMtWithdraw,
	Types.IntentMtWithdraw
>(() =>
	ajv.compile(
		schemas.IntentMtWithdraw as JSONSchemaType<Types.IntentMtWithdraw>,
	),
);
export const IntentNativeWithdrawValidator = wrapValidator<
	Types.IntentNativeWithdraw,
	Types.IntentNativeWithdraw
>(() =>
	ajv.compile(
		schemas.IntentNativeWithdraw as JSONSchemaType<Types.IntentNativeWithdraw>,
	),
);
export const IntentStorageDepositValidator = wrapValidator<
	Types.IntentStorageDeposit,
	Types.IntentStorageDeposit
>(() =>
	ajv.compile(
		schemas.IntentStorageDeposit as JSONSchemaType<Types.IntentStorageDeposit>,
	),
);
export const IntentTokenDiffValidator = wrapValidator<
	Types.IntentTokenDiff,
	Types.IntentTokenDiff
>(() =>
	ajv.compile(schemas.IntentTokenDiff as JSONSchemaType<Types.IntentTokenDiff>),
);
export const IntentSetAuthByPredecessorIdValidator = wrapValidator<
	Types.IntentSetAuthByPredecessorId,
	Types.IntentSetAuthByPredecessorId
>(() =>
	ajv.compile(
		schemas.IntentSetAuthByPredecessorId as JSONSchemaType<Types.IntentSetAuthByPredecessorId>,
	),
);
export const IntentAuthCallValidator = wrapValidator<
	Types.IntentAuthCall,
	Types.IntentAuthCall
>(() =>
	ajv.compile(schemas.IntentAuthCall as JSONSchemaType<Types.IntentAuthCall>),
);
export const IntentImtMintValidator = wrapValidator<
	Types.IntentImtMint,
	Types.IntentImtMint
>(() =>
	ajv.compile(schemas.IntentImtMint as JSONSchemaType<Types.IntentImtMint>),
);
export const IntentImtBurnValidator = wrapValidator<
	Types.IntentImtBurn,
	Types.IntentImtBurn
>(() =>
	ajv.compile(schemas.IntentImtBurn as JSONSchemaType<Types.IntentImtBurn>),
);
export const InvariantViolatedUnmatchedDeltasValidator = wrapValidator<
	Types.InvariantViolatedUnmatchedDeltas,
	Types.InvariantViolatedUnmatchedDeltas
>(() =>
	ajv.compile(
		schemas.InvariantViolatedUnmatchedDeltas as JSONSchemaType<Types.InvariantViolatedUnmatchedDeltas>,
	),
);
export const InvariantViolatedOverflowValidator = wrapValidator<
	Types.InvariantViolatedOverflow,
	Types.InvariantViolatedOverflow
>(() =>
	ajv.compile(
		schemas.InvariantViolatedOverflow as JSONSchemaType<Types.InvariantViolatedOverflow>,
	),
);
export const MultiPayloadNep413Validator = wrapValidator<
	Types.MultiPayloadNep413,
	Types.MultiPayloadNep413
>(() =>
	ajv.compile(
		schemas.MultiPayloadNep413 as JSONSchemaType<Types.MultiPayloadNep413>,
	),
);
export const MultiPayloadErc191Validator = wrapValidator<
	Types.MultiPayloadErc191,
	Types.MultiPayloadErc191
>(() =>
	ajv.compile(
		schemas.MultiPayloadErc191 as JSONSchemaType<Types.MultiPayloadErc191>,
	),
);
export const MultiPayloadTip191Validator = wrapValidator<
	Types.MultiPayloadTip191,
	Types.MultiPayloadTip191
>(() =>
	ajv.compile(
		schemas.MultiPayloadTip191 as JSONSchemaType<Types.MultiPayloadTip191>,
	),
);
export const MultiPayloadRawEd25519Validator = wrapValidator<
	Types.MultiPayloadRawEd25519,
	Types.MultiPayloadRawEd25519
>(() =>
	ajv.compile(
		schemas.MultiPayloadRawEd25519 as JSONSchemaType<Types.MultiPayloadRawEd25519>,
	),
);
export const MultiPayloadWebauthnValidator = wrapValidator<
	Types.MultiPayloadWebauthn,
	Types.MultiPayloadWebauthn
>(() =>
	ajv.compile(
		schemas.MultiPayloadWebauthn as JSONSchemaType<Types.MultiPayloadWebauthn>,
	),
);
export const MultiPayloadTonConnectValidator = wrapValidator<
	Types.MultiPayloadTonConnect,
	Types.MultiPayloadTonConnect
>(() =>
	ajv.compile(
		schemas.MultiPayloadTonConnect as JSONSchemaType<Types.MultiPayloadTonConnect>,
	),
);
export const MultiPayloadSep53Validator = wrapValidator<
	Types.MultiPayloadSep53,
	Types.MultiPayloadSep53
>(() =>
	ajv.compile(
		schemas.MultiPayloadSep53 as JSONSchemaType<Types.MultiPayloadSep53>,
	),
);
export const StateInitV1Validator = wrapValidator<
	Types.StateInitV1,
	Types.StateInitV1
>(() => ajv.compile(schemas.StateInitV1 as JSONSchemaType<Types.StateInitV1>));
export const TonConnectPayloadSchemaTextValidator = wrapValidator<
	Types.TonConnectPayloadSchemaText,
	Types.TonConnectPayloadSchemaText
>(() =>
	ajv.compile(
		schemas.TonConnectPayloadSchemaText as JSONSchemaType<Types.TonConnectPayloadSchemaText>,
	),
);
export const Nep413DefusePayloadValidator = wrapValidator<
	Types.Nep413DefusePayload,
	Types.Nep413DefusePayload
>(() =>
	ajv.compile(
		schemas.Nep413DefusePayload as JSONSchemaType<Types.Nep413DefusePayload>,
	),
);
export const MultiPayloadNarrowedValidator = wrapValidator<
	Types.MultiPayloadNarrowed,
	Types.MultiPayloadNarrowed__Parsed
>(
	() =>
		compileParseJson<Types.MultiPayloadNarrowed__Parsed>(
			schemas.MultiPayloadNarrowed as JSONSchemaType<Types.MultiPayloadNarrowed__Parsed>,
		),
	true,
);

export type {
	StandardSchemaV1,
	ValidationResult,
	ValidationIssue,
	Validator,
	InferInput,
	InferOutput,
} from "./standard-schema.js";
